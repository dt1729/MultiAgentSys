# Copyright (c) 2008 The Board of Trustees of The Leland Stanford Junior University
# Copyright (c) 2011, 2012 Open Networking Foundation
# Copyright (c) 2012, 2013 Big Switch Networks, Inc.
# See the file LICENSE.pyloxi which should have been included in the source distribution

# Automatically generated by LOXI from template module.py
# Do not modify

import struct
import loxi
from . import util
import loxi.generic_util

import sys
ofp = sys.modules['loxi.of15']

class bsn_controller_connection(loxi.OFObject):

    def __init__(self, state=None, auxiliary_id=None, role=None, uri=None):
        if state != None:
            self.state = state
        else:
            self.state = 0
        if auxiliary_id != None:
            self.auxiliary_id = auxiliary_id
        else:
            self.auxiliary_id = 0
        if role != None:
            self.role = role
        else:
            self.role = 0
        if uri != None:
            self.uri = uri
        else:
            self.uri = ""
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.state))
        packed.append(struct.pack("!B", self.auxiliary_id))
        packed.append('\x00' * 2)
        packed.append(struct.pack("!L", self.role))
        packed.append(struct.pack("!256s", self.uri))
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = bsn_controller_connection()
        obj.state = reader.read("!B")[0]
        obj.auxiliary_id = reader.read("!B")[0]
        reader.skip(2)
        obj.role = reader.read("!L")[0]
        obj.uri = reader.read("!256s")[0].rstrip("\x00")
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.state != other.state: return False
        if self.auxiliary_id != other.auxiliary_id: return False
        if self.role != other.role: return False
        if self.uri != other.uri: return False
        return True

    def pretty_print(self, q):
        q.text("bsn_controller_connection {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("state = ");
                value_name_map = {0: 'OFP_BSN_CONTROLLER_CONNECTION_STATE_DISCONNECTED', 1: 'OFP_BSN_CONTROLLER_CONNECTION_STATE_CONNECTED'}
                if self.state in value_name_map:
                    q.text("%s(%d)" % (value_name_map[self.state], self.state))
                else:
                    q.text("%#x" % self.state)
                q.text(","); q.breakable()
                q.text("auxiliary_id = ");
                q.text("%#x" % self.auxiliary_id)
                q.text(","); q.breakable()
                q.text("role = ");
                value_name_map = {0: 'OFPCR_ROLE_NOCHANGE', 1: 'OFPCR_ROLE_EQUAL', 2: 'OFPCR_ROLE_MASTER', 3: 'OFPCR_ROLE_SLAVE'}
                if self.role in value_name_map:
                    q.text("%s(%d)" % (value_name_map[self.role], self.role))
                else:
                    q.text("%#x" % self.role)
                q.text(","); q.breakable()
                q.text("uri = ");
                q.pp(self.uri)
            q.breakable()
        q.text('}')


class bsn_debug_counter_desc_stats_entry(loxi.OFObject):

    def __init__(self, counter_id=None, name=None, description=None):
        if counter_id != None:
            self.counter_id = counter_id
        else:
            self.counter_id = 0
        if name != None:
            self.name = name
        else:
            self.name = ""
        if description != None:
            self.description = description
        else:
            self.description = ""
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!Q", self.counter_id))
        packed.append(struct.pack("!64s", self.name))
        packed.append(struct.pack("!256s", self.description))
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = bsn_debug_counter_desc_stats_entry()
        obj.counter_id = reader.read("!Q")[0]
        obj.name = reader.read("!64s")[0].rstrip("\x00")
        obj.description = reader.read("!256s")[0].rstrip("\x00")
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.counter_id != other.counter_id: return False
        if self.name != other.name: return False
        if self.description != other.description: return False
        return True

    def pretty_print(self, q):
        q.text("bsn_debug_counter_desc_stats_entry {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("counter_id = ");
                q.text("%#x" % self.counter_id)
                q.text(","); q.breakable()
                q.text("name = ");
                q.pp(self.name)
                q.text(","); q.breakable()
                q.text("description = ");
                q.pp(self.description)
            q.breakable()
        q.text('}')


class bsn_debug_counter_stats_entry(loxi.OFObject):

    def __init__(self, counter_id=None, value=None):
        if counter_id != None:
            self.counter_id = counter_id
        else:
            self.counter_id = 0
        if value != None:
            self.value = value
        else:
            self.value = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!Q", self.counter_id))
        packed.append(struct.pack("!Q", self.value))
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = bsn_debug_counter_stats_entry()
        obj.counter_id = reader.read("!Q")[0]
        obj.value = reader.read("!Q")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.counter_id != other.counter_id: return False
        if self.value != other.value: return False
        return True

    def pretty_print(self, q):
        q.text("bsn_debug_counter_stats_entry {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("counter_id = ");
                q.text("%#x" % self.counter_id)
                q.text(","); q.breakable()
                q.text("value = ");
                q.text("%#x" % self.value)
            q.breakable()
        q.text('}')


class bsn_flow_checksum_bucket_stats_entry(loxi.OFObject):

    def __init__(self, checksum=None):
        if checksum != None:
            self.checksum = checksum
        else:
            self.checksum = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!Q", self.checksum))
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = bsn_flow_checksum_bucket_stats_entry()
        obj.checksum = reader.read("!Q")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.checksum != other.checksum: return False
        return True

    def pretty_print(self, q):
        q.text("bsn_flow_checksum_bucket_stats_entry {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("checksum = ");
                q.text("%#x" % self.checksum)
            q.breakable()
        q.text('}')


class bsn_generic_stats_entry(loxi.OFObject):

    def __init__(self, tlvs=None):
        if tlvs != None:
            self.tlvs = tlvs
        else:
            self.tlvs = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 0
        packed.append(loxi.generic_util.pack_list(self.tlvs))
        length = sum([len(x) for x in packed])
        packed[0] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = bsn_generic_stats_entry()
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 2)
        obj.tlvs = loxi.generic_util.unpack_list(reader, ofp.bsn_tlv.bsn_tlv.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.tlvs != other.tlvs: return False
        return True

    def pretty_print(self, q):
        q.text("bsn_generic_stats_entry {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("tlvs = ");
                q.pp(self.tlvs)
            q.breakable()
        q.text('}')


class bsn_gentable_bucket_stats_entry(loxi.OFObject):

    def __init__(self, checksum=None):
        if checksum != None:
            self.checksum = checksum
        else:
            self.checksum = 0
        return

    def pack(self):
        packed = []
        packed.append(util.pack_checksum_128(self.checksum))
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = bsn_gentable_bucket_stats_entry()
        obj.checksum = util.unpack_checksum_128(reader)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.checksum != other.checksum: return False
        return True

    def pretty_print(self, q):
        q.text("bsn_gentable_bucket_stats_entry {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("checksum = ");
                q.pp(self.checksum)
            q.breakable()
        q.text('}')


class bsn_gentable_desc_stats_entry(loxi.OFObject):

    def __init__(self, table_id=None, name=None, buckets_size=None, max_entries=None):
        if table_id != None:
            self.table_id = table_id
        else:
            self.table_id = 0
        if name != None:
            self.name = name
        else:
            self.name = ""
        if buckets_size != None:
            self.buckets_size = buckets_size
        else:
            self.buckets_size = 0
        if max_entries != None:
            self.max_entries = max_entries
        else:
            self.max_entries = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 0
        packed.append(struct.pack("!H", self.table_id))
        packed.append(struct.pack("!32s", self.name))
        packed.append(struct.pack("!L", self.buckets_size))
        packed.append(struct.pack("!L", self.max_entries))
        packed.append('\x00' * 4)
        length = sum([len(x) for x in packed])
        packed[0] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = bsn_gentable_desc_stats_entry()
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 2)
        obj.table_id = reader.read("!H")[0]
        obj.name = reader.read("!32s")[0].rstrip("\x00")
        obj.buckets_size = reader.read("!L")[0]
        obj.max_entries = reader.read("!L")[0]
        reader.skip(4)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.table_id != other.table_id: return False
        if self.name != other.name: return False
        if self.buckets_size != other.buckets_size: return False
        if self.max_entries != other.max_entries: return False
        return True

    def pretty_print(self, q):
        q.text("bsn_gentable_desc_stats_entry {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("table_id = ");
                q.text("%#x" % self.table_id)
                q.text(","); q.breakable()
                q.text("name = ");
                q.pp(self.name)
                q.text(","); q.breakable()
                q.text("buckets_size = ");
                q.text("%#x" % self.buckets_size)
                q.text(","); q.breakable()
                q.text("max_entries = ");
                q.text("%#x" % self.max_entries)
            q.breakable()
        q.text('}')


class bsn_gentable_entry_desc_stats_entry(loxi.OFObject):

    def __init__(self, checksum=None, key=None, value=None):
        if checksum != None:
            self.checksum = checksum
        else:
            self.checksum = 0
        if key != None:
            self.key = key
        else:
            self.key = []
        if value != None:
            self.value = value
        else:
            self.value = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 0
        packed.append(struct.pack("!H", 0)) # placeholder for key_length at index 1
        packed.append(util.pack_checksum_128(self.checksum))
        packed.append(loxi.generic_util.pack_list(self.key))
        packed[1] = struct.pack("!H", len(packed[-1]))
        packed.append(loxi.generic_util.pack_list(self.value))
        length = sum([len(x) for x in packed])
        packed[0] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = bsn_gentable_entry_desc_stats_entry()
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 2)
        _key_length = reader.read("!H")[0]
        obj.checksum = util.unpack_checksum_128(reader)
        obj.key = loxi.generic_util.unpack_list(reader.slice(_key_length), ofp.bsn_tlv.bsn_tlv.unpack)
        obj.value = loxi.generic_util.unpack_list(reader, ofp.bsn_tlv.bsn_tlv.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.checksum != other.checksum: return False
        if self.key != other.key: return False
        if self.value != other.value: return False
        return True

    def pretty_print(self, q):
        q.text("bsn_gentable_entry_desc_stats_entry {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("checksum = ");
                q.pp(self.checksum)
                q.text(","); q.breakable()
                q.text("key = ");
                q.pp(self.key)
                q.text(","); q.breakable()
                q.text("value = ");
                q.pp(self.value)
            q.breakable()
        q.text('}')


class bsn_gentable_entry_stats_entry(loxi.OFObject):

    def __init__(self, key=None, stats=None):
        if key != None:
            self.key = key
        else:
            self.key = []
        if stats != None:
            self.stats = stats
        else:
            self.stats = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 0
        packed.append(struct.pack("!H", 0)) # placeholder for key_length at index 1
        packed.append(loxi.generic_util.pack_list(self.key))
        packed[1] = struct.pack("!H", len(packed[-1]))
        packed.append(loxi.generic_util.pack_list(self.stats))
        length = sum([len(x) for x in packed])
        packed[0] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = bsn_gentable_entry_stats_entry()
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 2)
        _key_length = reader.read("!H")[0]
        obj.key = loxi.generic_util.unpack_list(reader.slice(_key_length), ofp.bsn_tlv.bsn_tlv.unpack)
        obj.stats = loxi.generic_util.unpack_list(reader, ofp.bsn_tlv.bsn_tlv.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.key != other.key: return False
        if self.stats != other.stats: return False
        return True

    def pretty_print(self, q):
        q.text("bsn_gentable_entry_stats_entry {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("key = ");
                q.pp(self.key)
                q.text(","); q.breakable()
                q.text("stats = ");
                q.pp(self.stats)
            q.breakable()
        q.text('}')


class bsn_gentable_stats_entry(loxi.OFObject):

    def __init__(self, table_id=None, entry_count=None, checksum=None):
        if table_id != None:
            self.table_id = table_id
        else:
            self.table_id = 0
        if entry_count != None:
            self.entry_count = entry_count
        else:
            self.entry_count = 0
        if checksum != None:
            self.checksum = checksum
        else:
            self.checksum = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.table_id))
        packed.append('\x00' * 2)
        packed.append(struct.pack("!L", self.entry_count))
        packed.append(util.pack_checksum_128(self.checksum))
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = bsn_gentable_stats_entry()
        obj.table_id = reader.read("!H")[0]
        reader.skip(2)
        obj.entry_count = reader.read("!L")[0]
        obj.checksum = util.unpack_checksum_128(reader)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.table_id != other.table_id: return False
        if self.entry_count != other.entry_count: return False
        if self.checksum != other.checksum: return False
        return True

    def pretty_print(self, q):
        q.text("bsn_gentable_stats_entry {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("table_id = ");
                q.text("%#x" % self.table_id)
                q.text(","); q.breakable()
                q.text("entry_count = ");
                q.text("%#x" % self.entry_count)
                q.text(","); q.breakable()
                q.text("checksum = ");
                q.pp(self.checksum)
            q.breakable()
        q.text('}')


class bsn_interface(loxi.OFObject):

    def __init__(self, hw_addr=None, name=None, ipv4_addr=None, ipv4_netmask=None):
        if hw_addr != None:
            self.hw_addr = hw_addr
        else:
            self.hw_addr = [0,0,0,0,0,0]
        if name != None:
            self.name = name
        else:
            self.name = ""
        if ipv4_addr != None:
            self.ipv4_addr = ipv4_addr
        else:
            self.ipv4_addr = 0
        if ipv4_netmask != None:
            self.ipv4_netmask = ipv4_netmask
        else:
            self.ipv4_netmask = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!6B", *self.hw_addr))
        packed.append('\x00' * 2)
        packed.append(struct.pack("!16s", self.name))
        packed.append(struct.pack("!L", self.ipv4_addr))
        packed.append(struct.pack("!L", self.ipv4_netmask))
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = bsn_interface()
        obj.hw_addr = list(reader.read('!6B'))
        reader.skip(2)
        obj.name = reader.read("!16s")[0].rstrip("\x00")
        obj.ipv4_addr = reader.read("!L")[0]
        obj.ipv4_netmask = reader.read("!L")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.hw_addr != other.hw_addr: return False
        if self.name != other.name: return False
        if self.ipv4_addr != other.ipv4_addr: return False
        if self.ipv4_netmask != other.ipv4_netmask: return False
        return True

    def pretty_print(self, q):
        q.text("bsn_interface {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("hw_addr = ");
                q.text(util.pretty_mac(self.hw_addr))
                q.text(","); q.breakable()
                q.text("name = ");
                q.pp(self.name)
                q.text(","); q.breakable()
                q.text("ipv4_addr = ");
                q.text(util.pretty_ipv4(self.ipv4_addr))
                q.text(","); q.breakable()
                q.text("ipv4_netmask = ");
                q.text(util.pretty_ipv4(self.ipv4_netmask))
            q.breakable()
        q.text('}')


class bsn_lacp_stats_entry(loxi.OFObject):

    def __init__(self, port_no=None, actor_sys_priority=None, actor_sys_mac=None, actor_port_priority=None, actor_port_num=None, actor_key=None, convergence_status=None, partner_sys_priority=None, partner_sys_mac=None, partner_port_priority=None, partner_port_num=None, partner_key=None):
        if port_no != None:
            self.port_no = port_no
        else:
            self.port_no = 0
        if actor_sys_priority != None:
            self.actor_sys_priority = actor_sys_priority
        else:
            self.actor_sys_priority = 0
        if actor_sys_mac != None:
            self.actor_sys_mac = actor_sys_mac
        else:
            self.actor_sys_mac = [0,0,0,0,0,0]
        if actor_port_priority != None:
            self.actor_port_priority = actor_port_priority
        else:
            self.actor_port_priority = 0
        if actor_port_num != None:
            self.actor_port_num = actor_port_num
        else:
            self.actor_port_num = 0
        if actor_key != None:
            self.actor_key = actor_key
        else:
            self.actor_key = 0
        if convergence_status != None:
            self.convergence_status = convergence_status
        else:
            self.convergence_status = 0
        if partner_sys_priority != None:
            self.partner_sys_priority = partner_sys_priority
        else:
            self.partner_sys_priority = 0
        if partner_sys_mac != None:
            self.partner_sys_mac = partner_sys_mac
        else:
            self.partner_sys_mac = [0,0,0,0,0,0]
        if partner_port_priority != None:
            self.partner_port_priority = partner_port_priority
        else:
            self.partner_port_priority = 0
        if partner_port_num != None:
            self.partner_port_num = partner_port_num
        else:
            self.partner_port_num = 0
        if partner_key != None:
            self.partner_key = partner_key
        else:
            self.partner_key = 0
        return

    def pack(self):
        packed = []
        packed.append(util.pack_port_no(self.port_no))
        packed.append(struct.pack("!H", self.actor_sys_priority))
        packed.append(struct.pack("!6B", *self.actor_sys_mac))
        packed.append(struct.pack("!H", self.actor_port_priority))
        packed.append(struct.pack("!H", self.actor_port_num))
        packed.append(struct.pack("!H", self.actor_key))
        packed.append(struct.pack("!B", self.convergence_status))
        packed.append('\x00' * 1)
        packed.append(struct.pack("!H", self.partner_sys_priority))
        packed.append(struct.pack("!6B", *self.partner_sys_mac))
        packed.append(struct.pack("!H", self.partner_port_priority))
        packed.append(struct.pack("!H", self.partner_port_num))
        packed.append(struct.pack("!H", self.partner_key))
        packed.append('\x00' * 2)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = bsn_lacp_stats_entry()
        obj.port_no = util.unpack_port_no(reader)
        obj.actor_sys_priority = reader.read("!H")[0]
        obj.actor_sys_mac = list(reader.read('!6B'))
        obj.actor_port_priority = reader.read("!H")[0]
        obj.actor_port_num = reader.read("!H")[0]
        obj.actor_key = reader.read("!H")[0]
        obj.convergence_status = reader.read("!B")[0]
        reader.skip(1)
        obj.partner_sys_priority = reader.read("!H")[0]
        obj.partner_sys_mac = list(reader.read('!6B'))
        obj.partner_port_priority = reader.read("!H")[0]
        obj.partner_port_num = reader.read("!H")[0]
        obj.partner_key = reader.read("!H")[0]
        reader.skip(2)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.port_no != other.port_no: return False
        if self.actor_sys_priority != other.actor_sys_priority: return False
        if self.actor_sys_mac != other.actor_sys_mac: return False
        if self.actor_port_priority != other.actor_port_priority: return False
        if self.actor_port_num != other.actor_port_num: return False
        if self.actor_key != other.actor_key: return False
        if self.convergence_status != other.convergence_status: return False
        if self.partner_sys_priority != other.partner_sys_priority: return False
        if self.partner_sys_mac != other.partner_sys_mac: return False
        if self.partner_port_priority != other.partner_port_priority: return False
        if self.partner_port_num != other.partner_port_num: return False
        if self.partner_key != other.partner_key: return False
        return True

    def pretty_print(self, q):
        q.text("bsn_lacp_stats_entry {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("port_no = ");
                q.text(util.pretty_port(self.port_no))
                q.text(","); q.breakable()
                q.text("actor_sys_priority = ");
                q.text("%#x" % self.actor_sys_priority)
                q.text(","); q.breakable()
                q.text("actor_sys_mac = ");
                q.text(util.pretty_mac(self.actor_sys_mac))
                q.text(","); q.breakable()
                q.text("actor_port_priority = ");
                q.text("%#x" % self.actor_port_priority)
                q.text(","); q.breakable()
                q.text("actor_port_num = ");
                q.text("%#x" % self.actor_port_num)
                q.text(","); q.breakable()
                q.text("actor_key = ");
                q.text("%#x" % self.actor_key)
                q.text(","); q.breakable()
                q.text("convergence_status = ");
                q.text("%#x" % self.convergence_status)
                q.text(","); q.breakable()
                q.text("partner_sys_priority = ");
                q.text("%#x" % self.partner_sys_priority)
                q.text(","); q.breakable()
                q.text("partner_sys_mac = ");
                q.text(util.pretty_mac(self.partner_sys_mac))
                q.text(","); q.breakable()
                q.text("partner_port_priority = ");
                q.text("%#x" % self.partner_port_priority)
                q.text(","); q.breakable()
                q.text("partner_port_num = ");
                q.text("%#x" % self.partner_port_num)
                q.text(","); q.breakable()
                q.text("partner_key = ");
                q.text("%#x" % self.partner_key)
            q.breakable()
        q.text('}')


class bsn_port_counter_stats_entry(loxi.OFObject):

    def __init__(self, port_no=None, values=None):
        if port_no != None:
            self.port_no = port_no
        else:
            self.port_no = 0
        if values != None:
            self.values = values
        else:
            self.values = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 0
        packed.append('\x00' * 2)
        packed.append(util.pack_port_no(self.port_no))
        packed.append(loxi.generic_util.pack_list(self.values))
        length = sum([len(x) for x in packed])
        packed[0] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = bsn_port_counter_stats_entry()
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 2)
        reader.skip(2)
        obj.port_no = util.unpack_port_no(reader)
        obj.values = loxi.generic_util.unpack_list(reader, ofp.common.uint64.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.port_no != other.port_no: return False
        if self.values != other.values: return False
        return True

    def pretty_print(self, q):
        q.text("bsn_port_counter_stats_entry {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("port_no = ");
                q.text(util.pretty_port(self.port_no))
                q.text(","); q.breakable()
                q.text("values = ");
                q.pp(self.values)
            q.breakable()
        q.text('}')


class bsn_switch_pipeline_stats_entry(loxi.OFObject):

    def __init__(self, pipeline=None):
        if pipeline != None:
            self.pipeline = pipeline
        else:
            self.pipeline = ""
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!256s", self.pipeline))
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = bsn_switch_pipeline_stats_entry()
        obj.pipeline = reader.read("!256s")[0].rstrip("\x00")
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.pipeline != other.pipeline: return False
        return True

    def pretty_print(self, q):
        q.text("bsn_switch_pipeline_stats_entry {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("pipeline = ");
                q.pp(self.pipeline)
            q.breakable()
        q.text('}')


class bsn_table_checksum_stats_entry(loxi.OFObject):

    def __init__(self, table_id=None, checksum=None):
        if table_id != None:
            self.table_id = table_id
        else:
            self.table_id = 0
        if checksum != None:
            self.checksum = checksum
        else:
            self.checksum = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.table_id))
        packed.append(struct.pack("!Q", self.checksum))
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = bsn_table_checksum_stats_entry()
        obj.table_id = reader.read("!B")[0]
        obj.checksum = reader.read("!Q")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.table_id != other.table_id: return False
        if self.checksum != other.checksum: return False
        return True

    def pretty_print(self, q):
        q.text("bsn_table_checksum_stats_entry {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("table_id = ");
                q.text("%#x" % self.table_id)
                q.text(","); q.breakable()
                q.text("checksum = ");
                q.text("%#x" % self.checksum)
            q.breakable()
        q.text('}')


class bsn_vport(loxi.OFObject):
    subtypes = {}


    def __init__(self, type=None):
        if type != None:
            self.type = type
        else:
            self.type = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        subtype, = reader.peek('!H', 0)
        subclass = bsn_vport.subtypes.get(subtype)
        if subclass:
            return subclass.unpack(reader)

        obj = bsn_vport()
        obj.type = reader.read("!H")[0]
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.type != other.type: return False
        return True

    def pretty_print(self, q):
        q.text("bsn_vport {")
        with q.group():
            with q.indent(2):
                q.breakable()
            q.breakable()
        q.text('}')


class bsn_vlan_counter_stats_entry(loxi.OFObject):

    def __init__(self, vlan_vid=None, values=None):
        if vlan_vid != None:
            self.vlan_vid = vlan_vid
        else:
            self.vlan_vid = 0
        if values != None:
            self.values = values
        else:
            self.values = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 0
        packed.append(struct.pack("!H", self.vlan_vid))
        packed.append('\x00' * 4)
        packed.append(loxi.generic_util.pack_list(self.values))
        length = sum([len(x) for x in packed])
        packed[0] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = bsn_vlan_counter_stats_entry()
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 2)
        obj.vlan_vid = reader.read("!H")[0]
        reader.skip(4)
        obj.values = loxi.generic_util.unpack_list(reader, ofp.common.uint64.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.vlan_vid != other.vlan_vid: return False
        if self.values != other.values: return False
        return True

    def pretty_print(self, q):
        q.text("bsn_vlan_counter_stats_entry {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("vlan_vid = ");
                q.text("%#x" % self.vlan_vid)
                q.text(","); q.breakable()
                q.text("values = ");
                q.pp(self.values)
            q.breakable()
        q.text('}')


class bsn_vlan_mac(loxi.OFObject):

    def __init__(self, vlan_vid=None, mac=None):
        if vlan_vid != None:
            self.vlan_vid = vlan_vid
        else:
            self.vlan_vid = 0
        if mac != None:
            self.mac = mac
        else:
            self.mac = [0,0,0,0,0,0]
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.vlan_vid))
        packed.append(struct.pack("!6B", *self.mac))
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = bsn_vlan_mac()
        obj.vlan_vid = reader.read("!H")[0]
        obj.mac = list(reader.read('!6B'))
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.vlan_vid != other.vlan_vid: return False
        if self.mac != other.mac: return False
        return True

    def pretty_print(self, q):
        q.text("bsn_vlan_mac {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("vlan_vid = ");
                q.text("%#x" % self.vlan_vid)
                q.text(","); q.breakable()
                q.text("mac = ");
                q.text(util.pretty_mac(self.mac))
            q.breakable()
        q.text('}')


class bsn_vport_l2gre(bsn_vport):
    type = 1

    def __init__(self, flags=None, port_no=None, loopback_port_no=None, local_mac=None, nh_mac=None, src_ip=None, dst_ip=None, dscp=None, ttl=None, vpn=None, rate_limit=None, if_name=None):
        if flags != None:
            self.flags = flags
        else:
            self.flags = 0
        if port_no != None:
            self.port_no = port_no
        else:
            self.port_no = 0
        if loopback_port_no != None:
            self.loopback_port_no = loopback_port_no
        else:
            self.loopback_port_no = 0
        if local_mac != None:
            self.local_mac = local_mac
        else:
            self.local_mac = [0,0,0,0,0,0]
        if nh_mac != None:
            self.nh_mac = nh_mac
        else:
            self.nh_mac = [0,0,0,0,0,0]
        if src_ip != None:
            self.src_ip = src_ip
        else:
            self.src_ip = 0
        if dst_ip != None:
            self.dst_ip = dst_ip
        else:
            self.dst_ip = 0
        if dscp != None:
            self.dscp = dscp
        else:
            self.dscp = 0
        if ttl != None:
            self.ttl = ttl
        else:
            self.ttl = 0
        if vpn != None:
            self.vpn = vpn
        else:
            self.vpn = 0
        if rate_limit != None:
            self.rate_limit = rate_limit
        else:
            self.rate_limit = 0
        if if_name != None:
            self.if_name = if_name
        else:
            self.if_name = ""
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(struct.pack("!L", self.flags))
        packed.append(util.pack_port_no(self.port_no))
        packed.append(util.pack_port_no(self.loopback_port_no))
        packed.append(struct.pack("!6B", *self.local_mac))
        packed.append(struct.pack("!6B", *self.nh_mac))
        packed.append(struct.pack("!L", self.src_ip))
        packed.append(struct.pack("!L", self.dst_ip))
        packed.append(struct.pack("!B", self.dscp))
        packed.append(struct.pack("!B", self.ttl))
        packed.append('\x00' * 2)
        packed.append(struct.pack("!L", self.vpn))
        packed.append(struct.pack("!L", self.rate_limit))
        packed.append(struct.pack("!16s", self.if_name))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = bsn_vport_l2gre()
        _type = reader.read("!H")[0]
        assert(_type == 1)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.flags = reader.read("!L")[0]
        obj.port_no = util.unpack_port_no(reader)
        obj.loopback_port_no = util.unpack_port_no(reader)
        obj.local_mac = list(reader.read('!6B'))
        obj.nh_mac = list(reader.read('!6B'))
        obj.src_ip = reader.read("!L")[0]
        obj.dst_ip = reader.read("!L")[0]
        obj.dscp = reader.read("!B")[0]
        obj.ttl = reader.read("!B")[0]
        reader.skip(2)
        obj.vpn = reader.read("!L")[0]
        obj.rate_limit = reader.read("!L")[0]
        obj.if_name = reader.read("!16s")[0].rstrip("\x00")
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.flags != other.flags: return False
        if self.port_no != other.port_no: return False
        if self.loopback_port_no != other.loopback_port_no: return False
        if self.local_mac != other.local_mac: return False
        if self.nh_mac != other.nh_mac: return False
        if self.src_ip != other.src_ip: return False
        if self.dst_ip != other.dst_ip: return False
        if self.dscp != other.dscp: return False
        if self.ttl != other.ttl: return False
        if self.vpn != other.vpn: return False
        if self.rate_limit != other.rate_limit: return False
        if self.if_name != other.if_name: return False
        return True

    def pretty_print(self, q):
        q.text("bsn_vport_l2gre {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("flags = ");
                value_name_map = {1: 'OF_BSN_VPORT_L2GRE_LOCAL_MAC_IS_VALID', 2: 'OF_BSN_VPORT_L2GRE_DSCP_ASSIGN', 4: 'OF_BSN_VPORT_L2GRE_DSCP_COPY', 8: 'OF_BSN_VPORT_L2GRE_LOOPBACK_IS_VALID', 16: 'OF_BSN_VPORT_L2GRE_RATE_LIMIT_IS_VALID'}
                q.text(util.pretty_flags(self.flags, value_name_map.values()))
                q.text(","); q.breakable()
                q.text("port_no = ");
                q.text(util.pretty_port(self.port_no))
                q.text(","); q.breakable()
                q.text("loopback_port_no = ");
                q.text(util.pretty_port(self.loopback_port_no))
                q.text(","); q.breakable()
                q.text("local_mac = ");
                q.text(util.pretty_mac(self.local_mac))
                q.text(","); q.breakable()
                q.text("nh_mac = ");
                q.text(util.pretty_mac(self.nh_mac))
                q.text(","); q.breakable()
                q.text("src_ip = ");
                q.text(util.pretty_ipv4(self.src_ip))
                q.text(","); q.breakable()
                q.text("dst_ip = ");
                q.text(util.pretty_ipv4(self.dst_ip))
                q.text(","); q.breakable()
                q.text("dscp = ");
                q.text("%#x" % self.dscp)
                q.text(","); q.breakable()
                q.text("ttl = ");
                q.text("%#x" % self.ttl)
                q.text(","); q.breakable()
                q.text("vpn = ");
                q.text("%#x" % self.vpn)
                q.text(","); q.breakable()
                q.text("rate_limit = ");
                q.text("%#x" % self.rate_limit)
                q.text(","); q.breakable()
                q.text("if_name = ");
                q.pp(self.if_name)
            q.breakable()
        q.text('}')

bsn_vport.subtypes[1] = bsn_vport_l2gre

class bsn_vport_q_in_q(bsn_vport):
    type = 0

    def __init__(self, port_no=None, ingress_tpid=None, ingress_vlan_id=None, egress_tpid=None, egress_vlan_id=None, if_name=None):
        if port_no != None:
            self.port_no = port_no
        else:
            self.port_no = 0
        if ingress_tpid != None:
            self.ingress_tpid = ingress_tpid
        else:
            self.ingress_tpid = 0
        if ingress_vlan_id != None:
            self.ingress_vlan_id = ingress_vlan_id
        else:
            self.ingress_vlan_id = 0
        if egress_tpid != None:
            self.egress_tpid = egress_tpid
        else:
            self.egress_tpid = 0
        if egress_vlan_id != None:
            self.egress_vlan_id = egress_vlan_id
        else:
            self.egress_vlan_id = 0
        if if_name != None:
            self.if_name = if_name
        else:
            self.if_name = ""
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(struct.pack("!L", self.port_no))
        packed.append(struct.pack("!H", self.ingress_tpid))
        packed.append(struct.pack("!H", self.ingress_vlan_id))
        packed.append(struct.pack("!H", self.egress_tpid))
        packed.append(struct.pack("!H", self.egress_vlan_id))
        packed.append(struct.pack("!16s", self.if_name))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = bsn_vport_q_in_q()
        _type = reader.read("!H")[0]
        assert(_type == 0)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.port_no = reader.read("!L")[0]
        obj.ingress_tpid = reader.read("!H")[0]
        obj.ingress_vlan_id = reader.read("!H")[0]
        obj.egress_tpid = reader.read("!H")[0]
        obj.egress_vlan_id = reader.read("!H")[0]
        obj.if_name = reader.read("!16s")[0].rstrip("\x00")
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.port_no != other.port_no: return False
        if self.ingress_tpid != other.ingress_tpid: return False
        if self.ingress_vlan_id != other.ingress_vlan_id: return False
        if self.egress_tpid != other.egress_tpid: return False
        if self.egress_vlan_id != other.egress_vlan_id: return False
        if self.if_name != other.if_name: return False
        return True

    def pretty_print(self, q):
        q.text("bsn_vport_q_in_q {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("port_no = ");
                q.text("%#x" % self.port_no)
                q.text(","); q.breakable()
                q.text("ingress_tpid = ");
                q.text("%#x" % self.ingress_tpid)
                q.text(","); q.breakable()
                q.text("ingress_vlan_id = ");
                q.text("%#x" % self.ingress_vlan_id)
                q.text(","); q.breakable()
                q.text("egress_tpid = ");
                q.text("%#x" % self.egress_tpid)
                q.text(","); q.breakable()
                q.text("egress_vlan_id = ");
                q.text("%#x" % self.egress_vlan_id)
                q.text(","); q.breakable()
                q.text("if_name = ");
                q.pp(self.if_name)
            q.breakable()
        q.text('}')

bsn_vport.subtypes[0] = bsn_vport_q_in_q

class bsn_vrf_counter_stats_entry(loxi.OFObject):

    def __init__(self, vrf=None, values=None):
        if vrf != None:
            self.vrf = vrf
        else:
            self.vrf = 0
        if values != None:
            self.values = values
        else:
            self.values = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 0
        packed.append('\x00' * 2)
        packed.append(struct.pack("!L", self.vrf))
        packed.append(loxi.generic_util.pack_list(self.values))
        length = sum([len(x) for x in packed])
        packed[0] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = bsn_vrf_counter_stats_entry()
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 2)
        reader.skip(2)
        obj.vrf = reader.read("!L")[0]
        obj.values = loxi.generic_util.unpack_list(reader, ofp.common.uint64.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.vrf != other.vrf: return False
        if self.values != other.values: return False
        return True

    def pretty_print(self, q):
        q.text("bsn_vrf_counter_stats_entry {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("vrf = ");
                q.text("%#x" % self.vrf)
                q.text(","); q.breakable()
                q.text("values = ");
                q.pp(self.values)
            q.breakable()
        q.text('}')


class bucket(loxi.OFObject):

    def __init__(self, bucket_id=None, actions=None, properties=None):
        if bucket_id != None:
            self.bucket_id = bucket_id
        else:
            self.bucket_id = 0
        if actions != None:
            self.actions = actions
        else:
            self.actions = []
        if properties != None:
            self.properties = properties
        else:
            self.properties = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", 0)) # placeholder for len at index 0
        packed.append(struct.pack("!H", 0)) # placeholder for action_array_len at index 1
        packed.append(struct.pack("!L", self.bucket_id))
        packed.append(loxi.generic_util.pack_list(self.actions))
        packed[1] = struct.pack("!H", len(packed[-1]))
        packed.append(loxi.generic_util.pack_list(self.properties))
        length = sum([len(x) for x in packed])
        packed[0] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = bucket()
        _len = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_len, 2)
        _action_array_len = reader.read("!H")[0]
        obj.bucket_id = reader.read("!L")[0]
        obj.actions = loxi.generic_util.unpack_list(reader.slice(_action_array_len), ofp.action.action.unpack)
        obj.properties = loxi.generic_util.unpack_list(reader, ofp.common.group_bucket_prop.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.bucket_id != other.bucket_id: return False
        if self.actions != other.actions: return False
        if self.properties != other.properties: return False
        return True

    def pretty_print(self, q):
        q.text("bucket {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("bucket_id = ");
                value_name_map = {4294967040: 'OFPG_BUCKET_MAX', 4294967293: 'OFPG_BUCKET_FIRST', 4294967294: 'OFPG_BUCKET_LAST', 4294967295: 'OFPG_BUCKET_ALL'}
                if self.bucket_id in value_name_map:
                    q.text("%s(%d)" % (value_name_map[self.bucket_id], self.bucket_id))
                else:
                    q.text("%#x" % self.bucket_id)
                q.text(","); q.breakable()
                q.text("actions = ");
                q.pp(self.actions)
                q.text(","); q.breakable()
                q.text("properties = ");
                q.pp(self.properties)
            q.breakable()
        q.text('}')


class bucket_counter(loxi.OFObject):

    def __init__(self, packet_count=None, byte_count=None):
        if packet_count != None:
            self.packet_count = packet_count
        else:
            self.packet_count = 0
        if byte_count != None:
            self.byte_count = byte_count
        else:
            self.byte_count = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!Q", self.packet_count))
        packed.append(struct.pack("!Q", self.byte_count))
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = bucket_counter()
        obj.packet_count = reader.read("!Q")[0]
        obj.byte_count = reader.read("!Q")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.packet_count != other.packet_count: return False
        if self.byte_count != other.byte_count: return False
        return True

    def pretty_print(self, q):
        q.text("bucket_counter {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("packet_count = ");
                q.text("%#x" % self.packet_count)
                q.text(","); q.breakable()
                q.text("byte_count = ");
                q.text("%#x" % self.byte_count)
            q.breakable()
        q.text('}')


class bundle_features_prop(loxi.OFObject):
    subtypes = {}


    def __init__(self, type=None):
        if type != None:
            self.type = type
        else:
            self.type = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        subtype, = reader.peek('!H', 0)
        subclass = bundle_features_prop.subtypes.get(subtype)
        if subclass:
            return subclass.unpack(reader)

        obj = bundle_features_prop()
        obj.type = reader.read("!H")[0]
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.type != other.type: return False
        return True

    def pretty_print(self, q):
        q.text("bundle_features_prop {")
        with q.group():
            with q.indent(2):
                q.breakable()
            q.breakable()
        q.text('}')


class time(loxi.OFObject):

    def __init__(self, seconds=None, nanoseconds=None):
        if seconds != None:
            self.seconds = seconds
        else:
            self.seconds = 0
        if nanoseconds != None:
            self.nanoseconds = nanoseconds
        else:
            self.nanoseconds = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!Q", self.seconds))
        packed.append(struct.pack("!L", self.nanoseconds))
        packed.append('\x00' * 4)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = time()
        obj.seconds = reader.read("!Q")[0]
        obj.nanoseconds = reader.read("!L")[0]
        reader.skip(4)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.seconds != other.seconds: return False
        if self.nanoseconds != other.nanoseconds: return False
        return True

    def pretty_print(self, q):
        q.text("time {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("seconds = ");
                q.text("%#x" % self.seconds)
                q.text(","); q.breakable()
                q.text("nanoseconds = ");
                q.text("%#x" % self.nanoseconds)
            q.breakable()
        q.text('}')


class bundle_features_prop_time(bundle_features_prop):
    type = 1

    def __init__(self, sched_accuracy=None, sched_max_future=None, sched_max_past=None, timestamp=None):
        if sched_accuracy != None:
            self.sched_accuracy = sched_accuracy
        else:
            self.sched_accuracy = loxi.unimplemented('init of_time_t')
        if sched_max_future != None:
            self.sched_max_future = sched_max_future
        else:
            self.sched_max_future = loxi.unimplemented('init of_time_t')
        if sched_max_past != None:
            self.sched_max_past = sched_max_past
        else:
            self.sched_max_past = loxi.unimplemented('init of_time_t')
        if timestamp != None:
            self.timestamp = timestamp
        else:
            self.timestamp = loxi.unimplemented('init of_time_t')
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append('\x00' * 4)
        packed.append(loxi.unimplemented('pack of_time_t'))
        packed.append(loxi.unimplemented('pack of_time_t'))
        packed.append(loxi.unimplemented('pack of_time_t'))
        packed.append(loxi.unimplemented('pack of_time_t'))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = bundle_features_prop_time()
        _type = reader.read("!H")[0]
        assert(_type == 1)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        reader.skip(4)
        obj.sched_accuracy = loxi.unimplemented('unpack of_time_t')
        obj.sched_max_future = loxi.unimplemented('unpack of_time_t')
        obj.sched_max_past = loxi.unimplemented('unpack of_time_t')
        obj.timestamp = loxi.unimplemented('unpack of_time_t')
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.sched_accuracy != other.sched_accuracy: return False
        if self.sched_max_future != other.sched_max_future: return False
        if self.sched_max_past != other.sched_max_past: return False
        if self.timestamp != other.timestamp: return False
        return True

    def pretty_print(self, q):
        q.text("bundle_features_prop_time {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("sched_accuracy = ");
                q.pp(self.sched_accuracy)
                q.text(","); q.breakable()
                q.text("sched_max_future = ");
                q.pp(self.sched_max_future)
                q.text(","); q.breakable()
                q.text("sched_max_past = ");
                q.pp(self.sched_max_past)
                q.text(","); q.breakable()
                q.text("timestamp = ");
                q.pp(self.timestamp)
            q.breakable()
        q.text('}')

bundle_features_prop.subtypes[1] = bundle_features_prop_time

class controller_status_entry(loxi.OFObject):

    def __init__(self, short_id=None, role=None, reason=None, channel_status=None, properties=None):
        if short_id != None:
            self.short_id = short_id
        else:
            self.short_id = 0
        if role != None:
            self.role = role
        else:
            self.role = 0
        if reason != None:
            self.reason = reason
        else:
            self.reason = 0
        if channel_status != None:
            self.channel_status = channel_status
        else:
            self.channel_status = 0
        if properties != None:
            self.properties = properties
        else:
            self.properties = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 0
        packed.append(struct.pack("!H", self.short_id))
        packed.append(struct.pack("!L", self.role))
        packed.append(struct.pack("!B", self.reason))
        packed.append(struct.pack("!B", self.channel_status))
        packed.append('\x00' * 6)
        packed.append(loxi.generic_util.pack_list(self.properties))
        length = sum([len(x) for x in packed])
        packed[0] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = controller_status_entry()
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 2)
        obj.short_id = reader.read("!H")[0]
        obj.role = reader.read("!L")[0]
        obj.reason = reader.read("!B")[0]
        obj.channel_status = reader.read("!B")[0]
        reader.skip(6)
        obj.properties = loxi.generic_util.unpack_list(reader, ofp.common.controller_status_prop.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.short_id != other.short_id: return False
        if self.role != other.role: return False
        if self.reason != other.reason: return False
        if self.channel_status != other.channel_status: return False
        if self.properties != other.properties: return False
        return True

    def pretty_print(self, q):
        q.text("controller_status_entry {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("short_id = ");
                q.text("%#x" % self.short_id)
                q.text(","); q.breakable()
                q.text("role = ");
                value_name_map = {0: 'OFPCR_ROLE_NOCHANGE', 1: 'OFPCR_ROLE_EQUAL', 2: 'OFPCR_ROLE_MASTER', 3: 'OFPCR_ROLE_SLAVE'}
                if self.role in value_name_map:
                    q.text("%s(%d)" % (value_name_map[self.role], self.role))
                else:
                    q.text("%#x" % self.role)
                q.text(","); q.breakable()
                q.text("reason = ");
                value_name_map = {0: 'OFPCSR_REQUEST', 1: 'OFPCSR_CHANNEL_STATUS', 2: 'OFPCSR_ROLE', 3: 'OFPCSR_CONTROLLER_ADDED', 4: 'OFPCSR_CONTROLLER_REMOVED', 5: 'OFPCSR_SHORT_ID', 6: 'OFPCSR_EXPERIMENTER'}
                if self.reason in value_name_map:
                    q.text("%s(%d)" % (value_name_map[self.reason], self.reason))
                else:
                    q.text("%#x" % self.reason)
                q.text(","); q.breakable()
                q.text("channel_status = ");
                value_name_map = {0: 'OFPCT_STATUS_UP', 1: 'OFPCT_STATUS_DOWN'}
                if self.channel_status in value_name_map:
                    q.text("%s(%d)" % (value_name_map[self.channel_status], self.channel_status))
                else:
                    q.text("%#x" % self.channel_status)
                q.text(","); q.breakable()
                q.text("properties = ");
                q.pp(self.properties)
            q.breakable()
        q.text('}')


class controller_status_prop(loxi.OFObject):
    subtypes = {}


    def __init__(self, type=None):
        if type != None:
            self.type = type
        else:
            self.type = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        subtype, = reader.peek('!H', 0)
        subclass = controller_status_prop.subtypes.get(subtype)
        if subclass:
            return subclass.unpack(reader)

        obj = controller_status_prop()
        obj.type = reader.read("!H")[0]
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.type != other.type: return False
        return True

    def pretty_print(self, q):
        q.text("controller_status_prop {")
        with q.group():
            with q.indent(2):
                q.breakable()
            q.breakable()
        q.text('}')


class flow_lightweight_stats_entry(loxi.OFObject):

    def __init__(self, table_id=None, reason=None, priority=None, match=None, stats=None):
        if table_id != None:
            self.table_id = table_id
        else:
            self.table_id = 0
        if reason != None:
            self.reason = reason
        else:
            self.reason = 0
        if priority != None:
            self.priority = priority
        else:
            self.priority = 0
        if match != None:
            self.match = match
        else:
            self.match = ofp.match()
        if stats != None:
            self.stats = stats
        else:
            self.stats = ofp.stat()
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 0
        packed.append('\x00' * 2)
        packed.append(struct.pack("!B", self.table_id))
        packed.append(struct.pack("!B", self.reason))
        packed.append(struct.pack("!H", self.priority))
        packed.append(self.match.pack())
        packed.append(self.stats.pack())
        length = sum([len(x) for x in packed])
        packed[0] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = flow_lightweight_stats_entry()
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 2)
        reader.skip(2)
        obj.table_id = reader.read("!B")[0]
        obj.reason = reader.read("!B")[0]
        obj.priority = reader.read("!H")[0]
        obj.match = ofp.match.unpack(reader)
        obj.stats = ofp.stat.unpack(reader)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.table_id != other.table_id: return False
        if self.reason != other.reason: return False
        if self.priority != other.priority: return False
        if self.match != other.match: return False
        if self.stats != other.stats: return False
        return True

    def pretty_print(self, q):
        q.text("flow_lightweight_stats_entry {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("table_id = ");
                q.text("%#x" % self.table_id)
                q.text(","); q.breakable()
                q.text("reason = ");
                value_name_map = {0: 'OFPFSR_STATS_REQUEST', 1: 'OFPFSR_STAT_TRIGGER'}
                if self.reason in value_name_map:
                    q.text("%s(%d)" % (value_name_map[self.reason], self.reason))
                else:
                    q.text("%#x" % self.reason)
                q.text(","); q.breakable()
                q.text("priority = ");
                q.text("%#x" % self.priority)
                q.text(","); q.breakable()
                q.text("match = ");
                q.pp(self.match)
                q.text(","); q.breakable()
                q.text("stats = ");
                q.pp(self.stats)
            q.breakable()
        q.text('}')


class flow_monitor_entry(loxi.OFObject):

    def __init__(self, monitor_id=None, out_port=None, out_group=None, flags=None, table_id=None, command=None, match=None):
        if monitor_id != None:
            self.monitor_id = monitor_id
        else:
            self.monitor_id = 0
        if out_port != None:
            self.out_port = out_port
        else:
            self.out_port = 0
        if out_group != None:
            self.out_group = out_group
        else:
            self.out_group = 0
        if flags != None:
            self.flags = flags
        else:
            self.flags = 0
        if table_id != None:
            self.table_id = table_id
        else:
            self.table_id = 0
        if command != None:
            self.command = command
        else:
            self.command = 0
        if match != None:
            self.match = match
        else:
            self.match = ofp.match()
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!L", self.monitor_id))
        packed.append(struct.pack("!L", self.out_port))
        packed.append(struct.pack("!L", self.out_group))
        packed.append(struct.pack("!H", self.flags))
        packed.append(struct.pack("!B", self.table_id))
        packed.append(struct.pack("!B", self.command))
        packed.append(self.match.pack())
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = flow_monitor_entry()
        obj.monitor_id = reader.read("!L")[0]
        obj.out_port = reader.read("!L")[0]
        obj.out_group = reader.read("!L")[0]
        obj.flags = reader.read("!H")[0]
        obj.table_id = reader.read("!B")[0]
        obj.command = reader.read("!B")[0]
        obj.match = ofp.match.unpack(reader)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.monitor_id != other.monitor_id: return False
        if self.out_port != other.out_port: return False
        if self.out_group != other.out_group: return False
        if self.flags != other.flags: return False
        if self.table_id != other.table_id: return False
        if self.command != other.command: return False
        if self.match != other.match: return False
        return True

    def pretty_print(self, q):
        q.text("flow_monitor_entry {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("monitor_id = ");
                q.text("%#x" % self.monitor_id)
                q.text(","); q.breakable()
                q.text("out_port = ");
                q.text("%#x" % self.out_port)
                q.text(","); q.breakable()
                q.text("out_group = ");
                q.text("%#x" % self.out_group)
                q.text(","); q.breakable()
                q.text("flags = ");
                value_name_map = {1: 'OFPFMF_INITIAL', 2: 'OFPFMF_ADD', 4: 'OFPFMF_REMOVED', 8: 'OFPFMF_MODIFY', 16: 'OFPFMF_INSTRUCTIONS', 32: 'OFPFMF_NO_ABBREV', 64: 'OFPFMF_ONLY_OWN'}
                q.text(util.pretty_flags(self.flags, value_name_map.values()))
                q.text(","); q.breakable()
                q.text("table_id = ");
                q.text("%#x" % self.table_id)
                q.text(","); q.breakable()
                q.text("command = ");
                value_name_map = {0: 'OFPFMC_ADD', 1: 'OFPFMC_MODIFY', 2: 'OFPFMC_DELETE'}
                if self.command in value_name_map:
                    q.text("%s(%d)" % (value_name_map[self.command], self.command))
                else:
                    q.text("%#x" % self.command)
                q.text(","); q.breakable()
                q.text("match = ");
                q.pp(self.match)
            q.breakable()
        q.text('}')


class flow_monitor_reply_entry(loxi.OFObject):

    def __init__(self, event=None):
        if event != None:
            self.event = event
        else:
            self.event = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 0
        packed.append(struct.pack("!H", self.event))
        length = sum([len(x) for x in packed])
        packed[0] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = flow_monitor_reply_entry()
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 2)
        obj.event = reader.read("!H")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.event != other.event: return False
        return True

    def pretty_print(self, q):
        q.text("flow_monitor_reply_entry {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("event = ");
                value_name_map = {0: 'OFPFME_INITIAL', 1: 'OFPFME_ADDED', 2: 'OFPFME_REMOVED', 3: 'OFPFME_MODIFIED', 4: 'OFPFME_ABBREV', 5: 'OFPFME_PAUSED', 6: 'OFPFME_RESUMED'}
                if self.event in value_name_map:
                    q.text("%s(%d)" % (value_name_map[self.event], self.event))
                else:
                    q.text("%#x" % self.event)
            q.breakable()
        q.text('}')


class flow_stats_entry(loxi.OFObject):

    def __init__(self, table_id=None, priority=None, idle_timeout=None, hard_timeout=None, flags=None, importance=None, cookie=None, match=None, stats=None, instructions=None):
        if table_id != None:
            self.table_id = table_id
        else:
            self.table_id = 0
        if priority != None:
            self.priority = priority
        else:
            self.priority = 0
        if idle_timeout != None:
            self.idle_timeout = idle_timeout
        else:
            self.idle_timeout = 0
        if hard_timeout != None:
            self.hard_timeout = hard_timeout
        else:
            self.hard_timeout = 0
        if flags != None:
            self.flags = flags
        else:
            self.flags = 0
        if importance != None:
            self.importance = importance
        else:
            self.importance = 0
        if cookie != None:
            self.cookie = cookie
        else:
            self.cookie = 0
        if match != None:
            self.match = match
        else:
            self.match = ofp.match()
        if stats != None:
            self.stats = stats
        else:
            self.stats = ofp.stat()
        if instructions != None:
            self.instructions = instructions
        else:
            self.instructions = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 0
        packed.append('\x00' * 2)
        packed.append(struct.pack("!B", self.table_id))
        packed.append('\x00' * 1)
        packed.append(struct.pack("!H", self.priority))
        packed.append(struct.pack("!H", self.idle_timeout))
        packed.append(struct.pack("!H", self.hard_timeout))
        packed.append(struct.pack("!H", self.flags))
        packed.append(struct.pack("!H", self.importance))
        packed.append(struct.pack("!Q", self.cookie))
        packed.append(self.match.pack())
        packed.append(self.stats.pack())
        packed.append(loxi.generic_util.pack_list(self.instructions))
        length = sum([len(x) for x in packed])
        packed[0] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = flow_stats_entry()
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 2)
        reader.skip(2)
        obj.table_id = reader.read("!B")[0]
        reader.skip(1)
        obj.priority = reader.read("!H")[0]
        obj.idle_timeout = reader.read("!H")[0]
        obj.hard_timeout = reader.read("!H")[0]
        obj.flags = reader.read("!H")[0]
        obj.importance = reader.read("!H")[0]
        obj.cookie = reader.read("!Q")[0]
        obj.match = ofp.match.unpack(reader)
        obj.stats = ofp.stat.unpack(reader)
        obj.instructions = loxi.generic_util.unpack_list(reader, ofp.instruction.instruction.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.table_id != other.table_id: return False
        if self.priority != other.priority: return False
        if self.idle_timeout != other.idle_timeout: return False
        if self.hard_timeout != other.hard_timeout: return False
        if self.flags != other.flags: return False
        if self.importance != other.importance: return False
        if self.cookie != other.cookie: return False
        if self.match != other.match: return False
        if self.stats != other.stats: return False
        if self.instructions != other.instructions: return False
        return True

    def pretty_print(self, q):
        q.text("flow_stats_entry {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("table_id = ");
                q.text("%#x" % self.table_id)
                q.text(","); q.breakable()
                q.text("priority = ");
                q.text("%#x" % self.priority)
                q.text(","); q.breakable()
                q.text("idle_timeout = ");
                q.text("%#x" % self.idle_timeout)
                q.text(","); q.breakable()
                q.text("hard_timeout = ");
                q.text("%#x" % self.hard_timeout)
                q.text(","); q.breakable()
                q.text("flags = ");
                value_name_map = {1: 'OFPFF_SEND_FLOW_REM', 2: 'OFPFF_CHECK_OVERLAP', 4: 'OFPFF_RESET_COUNTS', 8: 'OFPFF_NO_PKT_COUNTS', 16: 'OFPFF_NO_BYT_COUNTS', 128: 'OFPFF_BSN_SEND_IDLE'}
                q.text(util.pretty_flags(self.flags, value_name_map.values()))
                q.text(","); q.breakable()
                q.text("importance = ");
                q.text("%#x" % self.importance)
                q.text(","); q.breakable()
                q.text("cookie = ");
                q.text("%#x" % self.cookie)
                q.text(","); q.breakable()
                q.text("match = ");
                q.pp(self.match)
                q.text(","); q.breakable()
                q.text("stats = ");
                q.pp(self.stats)
                q.text(","); q.breakable()
                q.text("instructions = ");
                q.pp(self.instructions)
            q.breakable()
        q.text('}')


class group_bucket_prop(loxi.OFObject):
    subtypes = {}


    def __init__(self, type=None):
        if type != None:
            self.type = type
        else:
            self.type = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        subtype, = reader.peek('!H', 0)
        subclass = group_bucket_prop.subtypes.get(subtype)
        if subclass:
            return subclass.unpack(reader)

        obj = group_bucket_prop()
        obj.type = reader.read("!H")[0]
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.type != other.type: return False
        return True

    def pretty_print(self, q):
        q.text("group_bucket_prop {")
        with q.group():
            with q.indent(2):
                q.breakable()
            q.breakable()
        q.text('}')


class group_bucket_prop_experimenter(group_bucket_prop):
    subtypes = {}

    type = 3

    def __init__(self, experimenter=None, exp_type=None):
        if experimenter != None:
            self.experimenter = experimenter
        else:
            self.experimenter = 0
        if exp_type != None:
            self.exp_type = exp_type
        else:
            self.exp_type = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(struct.pack("!L", self.experimenter))
        packed.append(struct.pack("!L", self.exp_type))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        subtype, = reader.peek('!L', 4)
        subclass = group_bucket_prop_experimenter.subtypes.get(subtype)
        if subclass:
            return subclass.unpack(reader)

        obj = group_bucket_prop_experimenter()
        _type = reader.read("!H")[0]
        assert(_type == 3)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.experimenter = reader.read("!L")[0]
        obj.exp_type = reader.read("!L")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.experimenter != other.experimenter: return False
        if self.exp_type != other.exp_type: return False
        return True

    def pretty_print(self, q):
        q.text("group_bucket_prop_experimenter {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("exp_type = ");
                q.text("%#x" % self.exp_type)
            q.breakable()
        q.text('}')

group_bucket_prop.subtypes[3] = group_bucket_prop_experimenter

class group_bucket_prop_watch_group(group_bucket_prop):
    type = 2

    def __init__(self, watch=None):
        if watch != None:
            self.watch = watch
        else:
            self.watch = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(struct.pack("!L", self.watch))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = group_bucket_prop_watch_group()
        _type = reader.read("!H")[0]
        assert(_type == 2)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.watch = reader.read("!L")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.watch != other.watch: return False
        return True

    def pretty_print(self, q):
        q.text("group_bucket_prop_watch_group {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("watch = ");
                q.text("%#x" % self.watch)
            q.breakable()
        q.text('}')

group_bucket_prop.subtypes[2] = group_bucket_prop_watch_group

class group_bucket_prop_watch_port(group_bucket_prop):
    type = 1

    def __init__(self, watch=None):
        if watch != None:
            self.watch = watch
        else:
            self.watch = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(struct.pack("!L", self.watch))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = group_bucket_prop_watch_port()
        _type = reader.read("!H")[0]
        assert(_type == 1)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.watch = reader.read("!L")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.watch != other.watch: return False
        return True

    def pretty_print(self, q):
        q.text("group_bucket_prop_watch_port {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("watch = ");
                q.text("%#x" % self.watch)
            q.breakable()
        q.text('}')

group_bucket_prop.subtypes[1] = group_bucket_prop_watch_port

class group_bucket_prop_weight(group_bucket_prop):
    type = 0

    def __init__(self, weight=None):
        if weight != None:
            self.weight = weight
        else:
            self.weight = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(struct.pack("!H", self.weight))
        packed.append('\x00' * 2)
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = group_bucket_prop_weight()
        _type = reader.read("!H")[0]
        assert(_type == 0)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.weight = reader.read("!H")[0]
        reader.skip(2)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.weight != other.weight: return False
        return True

    def pretty_print(self, q):
        q.text("group_bucket_prop_weight {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("weight = ");
                q.text("%#x" % self.weight)
            q.breakable()
        q.text('}')

group_bucket_prop.subtypes[0] = group_bucket_prop_weight

class group_desc_stats_entry(loxi.OFObject):

    def __init__(self, group_type=None, group_id=None, buckets=None, properties=None):
        if group_type != None:
            self.group_type = group_type
        else:
            self.group_type = 0
        if group_id != None:
            self.group_id = group_id
        else:
            self.group_id = 0
        if buckets != None:
            self.buckets = buckets
        else:
            self.buckets = []
        if properties != None:
            self.properties = properties
        else:
            self.properties = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 0
        packed.append(struct.pack("!B", self.group_type))
        packed.append('\x00' * 1)
        packed.append(struct.pack("!L", self.group_id))
        packed.append(struct.pack("!H", 0)) # placeholder for bucket_array_len at index 4
        packed.append('\x00' * 6)
        packed.append(loxi.generic_util.pack_list(self.buckets))
        packed[4] = struct.pack("!H", len(packed[-1]))
        packed.append(loxi.generic_util.pack_list(self.properties))
        length = sum([len(x) for x in packed])
        packed[0] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = group_desc_stats_entry()
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 2)
        obj.group_type = reader.read("!B")[0]
        reader.skip(1)
        obj.group_id = reader.read("!L")[0]
        _bucket_array_len = reader.read("!H")[0]
        reader.skip(6)
        obj.buckets = loxi.generic_util.unpack_list(reader.slice(_bucket_array_len), ofp.common.bucket.unpack)
        obj.properties = loxi.generic_util.unpack_list(reader, ofp.common.group_prop.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.group_type != other.group_type: return False
        if self.group_id != other.group_id: return False
        if self.buckets != other.buckets: return False
        if self.properties != other.properties: return False
        return True

    def pretty_print(self, q):
        q.text("group_desc_stats_entry {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("group_type = ");
                value_name_map = {0: 'OFPGT_ALL', 1: 'OFPGT_SELECT', 2: 'OFPGT_INDIRECT', 3: 'OFPGT_FF'}
                if self.group_type in value_name_map:
                    q.text("%s(%d)" % (value_name_map[self.group_type], self.group_type))
                else:
                    q.text("%#x" % self.group_type)
                q.text(","); q.breakable()
                q.text("group_id = ");
                q.text("%#x" % self.group_id)
                q.text(","); q.breakable()
                q.text("buckets = ");
                q.pp(self.buckets)
                q.text(","); q.breakable()
                q.text("properties = ");
                q.pp(self.properties)
            q.breakable()
        q.text('}')


class group_prop(loxi.OFObject):
    subtypes = {}


    def __init__(self, type=None):
        if type != None:
            self.type = type
        else:
            self.type = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        subtype, = reader.peek('!H', 0)
        subclass = group_prop.subtypes.get(subtype)
        if subclass:
            return subclass.unpack(reader)

        obj = group_prop()
        obj.type = reader.read("!H")[0]
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.type != other.type: return False
        return True

    def pretty_print(self, q):
        q.text("group_prop {")
        with q.group():
            with q.indent(2):
                q.breakable()
            q.breakable()
        q.text('}')


class group_prop_experimenter(loxi.OFObject):
    subtypes = {}

    type = 65535

    def __init__(self, experimenter=None, exp_type=None):
        if experimenter != None:
            self.experimenter = experimenter
        else:
            self.experimenter = 0
        if exp_type != None:
            self.exp_type = exp_type
        else:
            self.exp_type = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(struct.pack("!L", self.experimenter))
        packed.append(struct.pack("!L", self.exp_type))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        subtype, = reader.peek('!L', 4)
        subclass = group_prop_experimenter.subtypes.get(subtype)
        if subclass:
            return subclass.unpack(reader)

        obj = group_prop_experimenter()
        _type = reader.read("!H")[0]
        assert(_type == 65535)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.experimenter = reader.read("!L")[0]
        obj.exp_type = reader.read("!L")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.experimenter != other.experimenter: return False
        if self.exp_type != other.exp_type: return False
        return True

    def pretty_print(self, q):
        q.text("group_prop_experimenter {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("exp_type = ");
                q.text("%#x" % self.exp_type)
            q.breakable()
        q.text('}')


class group_stats_entry(loxi.OFObject):

    def __init__(self, group_id=None, ref_count=None, packet_count=None, byte_count=None, duration_sec=None, duration_nsec=None, bucket_stats=None):
        if group_id != None:
            self.group_id = group_id
        else:
            self.group_id = 0
        if ref_count != None:
            self.ref_count = ref_count
        else:
            self.ref_count = 0
        if packet_count != None:
            self.packet_count = packet_count
        else:
            self.packet_count = 0
        if byte_count != None:
            self.byte_count = byte_count
        else:
            self.byte_count = 0
        if duration_sec != None:
            self.duration_sec = duration_sec
        else:
            self.duration_sec = 0
        if duration_nsec != None:
            self.duration_nsec = duration_nsec
        else:
            self.duration_nsec = 0
        if bucket_stats != None:
            self.bucket_stats = bucket_stats
        else:
            self.bucket_stats = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 0
        packed.append('\x00' * 2)
        packed.append(struct.pack("!L", self.group_id))
        packed.append(struct.pack("!L", self.ref_count))
        packed.append('\x00' * 4)
        packed.append(struct.pack("!Q", self.packet_count))
        packed.append(struct.pack("!Q", self.byte_count))
        packed.append(struct.pack("!L", self.duration_sec))
        packed.append(struct.pack("!L", self.duration_nsec))
        packed.append(loxi.generic_util.pack_list(self.bucket_stats))
        length = sum([len(x) for x in packed])
        packed[0] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = group_stats_entry()
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 2)
        reader.skip(2)
        obj.group_id = reader.read("!L")[0]
        obj.ref_count = reader.read("!L")[0]
        reader.skip(4)
        obj.packet_count = reader.read("!Q")[0]
        obj.byte_count = reader.read("!Q")[0]
        obj.duration_sec = reader.read("!L")[0]
        obj.duration_nsec = reader.read("!L")[0]
        obj.bucket_stats = loxi.generic_util.unpack_list(reader, ofp.common.bucket_counter.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.group_id != other.group_id: return False
        if self.ref_count != other.ref_count: return False
        if self.packet_count != other.packet_count: return False
        if self.byte_count != other.byte_count: return False
        if self.duration_sec != other.duration_sec: return False
        if self.duration_nsec != other.duration_nsec: return False
        if self.bucket_stats != other.bucket_stats: return False
        return True

    def pretty_print(self, q):
        q.text("group_stats_entry {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("group_id = ");
                q.text("%#x" % self.group_id)
                q.text(","); q.breakable()
                q.text("ref_count = ");
                q.text("%#x" % self.ref_count)
                q.text(","); q.breakable()
                q.text("packet_count = ");
                q.text("%#x" % self.packet_count)
                q.text(","); q.breakable()
                q.text("byte_count = ");
                q.text("%#x" % self.byte_count)
                q.text(","); q.breakable()
                q.text("duration_sec = ");
                q.text("%#x" % self.duration_sec)
                q.text(","); q.breakable()
                q.text("duration_nsec = ");
                q.text("%#x" % self.duration_nsec)
                q.text(","); q.breakable()
                q.text("bucket_stats = ");
                q.pp(self.bucket_stats)
            q.breakable()
        q.text('}')


class header_type(loxi.OFObject):
    subtypes = {}


    def __init__(self, namespace=None, ns_type=None):
        if namespace != None:
            self.namespace = namespace
        else:
            self.namespace = 0
        if ns_type != None:
            self.ns_type = ns_type
        else:
            self.ns_type = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.namespace))
        packed.append(struct.pack("!H", self.ns_type))
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        subtype, = reader.peek('!H', 0)
        subclass = header_type.subtypes.get(subtype)
        if subclass:
            return subclass.unpack(reader)

        obj = header_type()
        obj.namespace = reader.read("!H")[0]
        obj.ns_type = reader.read("!H")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.namespace != other.namespace: return False
        if self.ns_type != other.ns_type: return False
        return True

    def pretty_print(self, q):
        q.text("header_type {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("ns_type = ");
                q.text("%#x" % self.ns_type)
            q.breakable()
        q.text('}')


class hello_elem(loxi.OFObject):
    subtypes = {}


    def __init__(self, type=None):
        if type != None:
            self.type = type
        else:
            self.type = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        subtype, = reader.peek('!H', 0)
        subclass = hello_elem.subtypes.get(subtype)
        if subclass:
            return subclass.unpack(reader)

        obj = hello_elem()
        obj.type = reader.read("!H")[0]
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.type != other.type: return False
        return True

    def pretty_print(self, q):
        q.text("hello_elem {")
        with q.group():
            with q.indent(2):
                q.breakable()
            q.breakable()
        q.text('}')


class hello_elem_versionbitmap(hello_elem):
    type = 1

    def __init__(self, bitmaps=None):
        if bitmaps != None:
            self.bitmaps = bitmaps
        else:
            self.bitmaps = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(loxi.generic_util.pack_list(self.bitmaps))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = hello_elem_versionbitmap()
        _type = reader.read("!H")[0]
        assert(_type == 1)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.bitmaps = loxi.generic_util.unpack_list(reader, ofp.common.uint32.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.bitmaps != other.bitmaps: return False
        return True

    def pretty_print(self, q):
        q.text("hello_elem_versionbitmap {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("bitmaps = ");
                q.pp(self.bitmaps)
            q.breakable()
        q.text('}')

hello_elem.subtypes[1] = hello_elem_versionbitmap

class match_v3(loxi.OFObject):
    type = 1

    def __init__(self, oxm_list=None):
        if oxm_list != None:
            self.oxm_list = oxm_list
        else:
            self.oxm_list = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(loxi.generic_util.pack_list(self.oxm_list))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        packed.append(loxi.generic_util.pad_to(8, length))
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = match_v3()
        _type = reader.read("!H")[0]
        assert(_type == 1)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.oxm_list = loxi.generic_util.unpack_list(reader, ofp.oxm.oxm.unpack)
        orig_reader.skip_align()
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.oxm_list != other.oxm_list: return False
        return True

    def pretty_print(self, q):
        q.text("match_v3 {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("oxm_list = ");
                q.pp(self.oxm_list)
            q.breakable()
        q.text('}')


class meter_band_stats(loxi.OFObject):

    def __init__(self, packet_band_count=None, byte_band_count=None):
        if packet_band_count != None:
            self.packet_band_count = packet_band_count
        else:
            self.packet_band_count = 0
        if byte_band_count != None:
            self.byte_band_count = byte_band_count
        else:
            self.byte_band_count = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!Q", self.packet_band_count))
        packed.append(struct.pack("!Q", self.byte_band_count))
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = meter_band_stats()
        obj.packet_band_count = reader.read("!Q")[0]
        obj.byte_band_count = reader.read("!Q")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.packet_band_count != other.packet_band_count: return False
        if self.byte_band_count != other.byte_band_count: return False
        return True

    def pretty_print(self, q):
        q.text("meter_band_stats {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("packet_band_count = ");
                q.text("%#x" % self.packet_band_count)
                q.text(","); q.breakable()
                q.text("byte_band_count = ");
                q.text("%#x" % self.byte_band_count)
            q.breakable()
        q.text('}')


class meter_config(loxi.OFObject):

    def __init__(self, flags=None, meter_id=None, entries=None):
        if flags != None:
            self.flags = flags
        else:
            self.flags = 0
        if meter_id != None:
            self.meter_id = meter_id
        else:
            self.meter_id = 0
        if entries != None:
            self.entries = entries
        else:
            self.entries = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 0
        packed.append(struct.pack("!H", self.flags))
        packed.append(struct.pack("!L", self.meter_id))
        packed.append(loxi.generic_util.pack_list(self.entries))
        length = sum([len(x) for x in packed])
        packed[0] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = meter_config()
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 2)
        obj.flags = reader.read("!H")[0]
        obj.meter_id = reader.read("!L")[0]
        obj.entries = loxi.generic_util.unpack_list(reader, ofp.meter_band.meter_band.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.flags != other.flags: return False
        if self.meter_id != other.meter_id: return False
        if self.entries != other.entries: return False
        return True

    def pretty_print(self, q):
        q.text("meter_config {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("flags = ");
                value_name_map = {1: 'OFPMF_KBPS', 2: 'OFPMF_PKTPS', 4: 'OFPMF_BURST', 8: 'OFPMF_STATS'}
                q.text(util.pretty_flags(self.flags, value_name_map.values()))
                q.text(","); q.breakable()
                q.text("meter_id = ");
                q.text("%#x" % self.meter_id)
                q.text(","); q.breakable()
                q.text("entries = ");
                q.pp(self.entries)
            q.breakable()
        q.text('}')


class meter_features(loxi.OFObject):

    def __init__(self, max_meter=None, band_types=None, capabilities=None, max_bands=None, max_color=None, features=None):
        if max_meter != None:
            self.max_meter = max_meter
        else:
            self.max_meter = 0
        if band_types != None:
            self.band_types = band_types
        else:
            self.band_types = 0
        if capabilities != None:
            self.capabilities = capabilities
        else:
            self.capabilities = 0
        if max_bands != None:
            self.max_bands = max_bands
        else:
            self.max_bands = 0
        if max_color != None:
            self.max_color = max_color
        else:
            self.max_color = 0
        if features != None:
            self.features = features
        else:
            self.features = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!L", self.max_meter))
        packed.append(struct.pack("!L", self.band_types))
        packed.append(struct.pack("!L", self.capabilities))
        packed.append(struct.pack("!B", self.max_bands))
        packed.append(struct.pack("!B", self.max_color))
        packed.append('\x00' * 2)
        packed.append(struct.pack("!L", self.features))
        packed.append('\x00' * 4)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = meter_features()
        obj.max_meter = reader.read("!L")[0]
        obj.band_types = reader.read("!L")[0]
        obj.capabilities = reader.read("!L")[0]
        obj.max_bands = reader.read("!B")[0]
        obj.max_color = reader.read("!B")[0]
        reader.skip(2)
        obj.features = reader.read("!L")[0]
        reader.skip(4)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.max_meter != other.max_meter: return False
        if self.band_types != other.band_types: return False
        if self.capabilities != other.capabilities: return False
        if self.max_bands != other.max_bands: return False
        if self.max_color != other.max_color: return False
        if self.features != other.features: return False
        return True

    def pretty_print(self, q):
        q.text("meter_features {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("max_meter = ");
                q.text("%#x" % self.max_meter)
                q.text(","); q.breakable()
                q.text("band_types = ");
                q.text("%#x" % self.band_types)
                q.text(","); q.breakable()
                q.text("capabilities = ");
                q.text("%#x" % self.capabilities)
                q.text(","); q.breakable()
                q.text("max_bands = ");
                q.text("%#x" % self.max_bands)
                q.text(","); q.breakable()
                q.text("max_color = ");
                q.text("%#x" % self.max_color)
                q.text(","); q.breakable()
                q.text("features = ");
                q.text("%#x" % self.features)
            q.breakable()
        q.text('}')


class meter_stats(loxi.OFObject):

    def __init__(self, meter_id=None, ref_count=None, packet_in_count=None, byte_in_count=None, duration_sec=None, duration_nsec=None, band_stats=None):
        if meter_id != None:
            self.meter_id = meter_id
        else:
            self.meter_id = 0
        if ref_count != None:
            self.ref_count = ref_count
        else:
            self.ref_count = 0
        if packet_in_count != None:
            self.packet_in_count = packet_in_count
        else:
            self.packet_in_count = 0
        if byte_in_count != None:
            self.byte_in_count = byte_in_count
        else:
            self.byte_in_count = 0
        if duration_sec != None:
            self.duration_sec = duration_sec
        else:
            self.duration_sec = 0
        if duration_nsec != None:
            self.duration_nsec = duration_nsec
        else:
            self.duration_nsec = 0
        if band_stats != None:
            self.band_stats = band_stats
        else:
            self.band_stats = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!L", self.meter_id))
        packed.append(struct.pack("!H", 0)) # placeholder for len at index 1
        packed.append('\x00' * 6)
        packed.append(struct.pack("!L", self.ref_count))
        packed.append(struct.pack("!Q", self.packet_in_count))
        packed.append(struct.pack("!Q", self.byte_in_count))
        packed.append(struct.pack("!L", self.duration_sec))
        packed.append(struct.pack("!L", self.duration_nsec))
        packed.append(loxi.generic_util.pack_list(self.band_stats))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = meter_stats()
        obj.meter_id = reader.read("!L")[0]
        _len = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_len, 6)
        reader.skip(6)
        obj.ref_count = reader.read("!L")[0]
        obj.packet_in_count = reader.read("!Q")[0]
        obj.byte_in_count = reader.read("!Q")[0]
        obj.duration_sec = reader.read("!L")[0]
        obj.duration_nsec = reader.read("!L")[0]
        obj.band_stats = loxi.generic_util.unpack_list(reader, ofp.common.meter_band_stats.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.meter_id != other.meter_id: return False
        if self.ref_count != other.ref_count: return False
        if self.packet_in_count != other.packet_in_count: return False
        if self.byte_in_count != other.byte_in_count: return False
        if self.duration_sec != other.duration_sec: return False
        if self.duration_nsec != other.duration_nsec: return False
        if self.band_stats != other.band_stats: return False
        return True

    def pretty_print(self, q):
        q.text("meter_stats {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("meter_id = ");
                q.text("%#x" % self.meter_id)
                q.text(","); q.breakable()
                q.text("ref_count = ");
                q.text("%#x" % self.ref_count)
                q.text(","); q.breakable()
                q.text("packet_in_count = ");
                q.text("%#x" % self.packet_in_count)
                q.text(","); q.breakable()
                q.text("byte_in_count = ");
                q.text("%#x" % self.byte_in_count)
                q.text(","); q.breakable()
                q.text("duration_sec = ");
                q.text("%#x" % self.duration_sec)
                q.text(","); q.breakable()
                q.text("duration_nsec = ");
                q.text("%#x" % self.duration_nsec)
                q.text(","); q.breakable()
                q.text("band_stats = ");
                q.pp(self.band_stats)
            q.breakable()
        q.text('}')


class oxs(loxi.OFObject):
    subtypes = {}


    def __init__(self, type_len=None):
        if type_len != None:
            self.type_len = type_len
        else:
            self.type_len = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!L", self.type_len))
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        subtype, = reader.peek('!L', 0)
        subclass = oxs.subtypes.get(subtype)
        if subclass:
            return subclass.unpack(reader)

        obj = oxs()
        obj.type_len = reader.read("!L")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.type_len != other.type_len: return False
        return True

    def pretty_print(self, q):
        q.text("oxs {")
        with q.group():
            with q.indent(2):
                q.breakable()
            q.breakable()
        q.text('}')


class oxs_byte_count(oxs):
    type_len = 2147616776

    def __init__(self, value=None):
        if value != None:
            self.value = value
        else:
            self.value = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!L", self.type_len))
        packed.append(struct.pack("!Q", self.value))
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = oxs_byte_count()
        _type_len = reader.read("!L")[0]
        assert(_type_len == 2147616776)
        obj.value = reader.read("!Q")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.value != other.value: return False
        return True

    def pretty_print(self, q):
        q.text("oxs_byte_count {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("value = ");
                q.text("%#x" % self.value)
            q.breakable()
        q.text('}')

oxs.subtypes[2147616776] = oxs_byte_count

class oxs_duration(oxs):
    type_len = 2147614728

    def __init__(self, value=None):
        if value != None:
            self.value = value
        else:
            self.value = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!L", self.type_len))
        packed.append(struct.pack("!Q", self.value))
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = oxs_duration()
        _type_len = reader.read("!L")[0]
        assert(_type_len == 2147614728)
        obj.value = reader.read("!Q")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.value != other.value: return False
        return True

    def pretty_print(self, q):
        q.text("oxs_duration {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("value = ");
                q.text("%#x" % self.value)
            q.breakable()
        q.text('}')

oxs.subtypes[2147614728] = oxs_duration

class oxs_flow_count(oxs):
    type_len = 2147615748

    def __init__(self, value=None):
        if value != None:
            self.value = value
        else:
            self.value = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!L", self.type_len))
        packed.append(struct.pack("!L", self.value))
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = oxs_flow_count()
        _type_len = reader.read("!L")[0]
        assert(_type_len == 2147615748)
        obj.value = reader.read("!L")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.value != other.value: return False
        return True

    def pretty_print(self, q):
        q.text("oxs_flow_count {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("value = ");
                q.text("%#x" % self.value)
            q.breakable()
        q.text('}')

oxs.subtypes[2147615748] = oxs_flow_count

class oxs_idle_time(oxs):
    type_len = 2147615240

    def __init__(self, value=None):
        if value != None:
            self.value = value
        else:
            self.value = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!L", self.type_len))
        packed.append(struct.pack("!Q", self.value))
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = oxs_idle_time()
        _type_len = reader.read("!L")[0]
        assert(_type_len == 2147615240)
        obj.value = reader.read("!Q")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.value != other.value: return False
        return True

    def pretty_print(self, q):
        q.text("oxs_idle_time {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("value = ");
                q.text("%#x" % self.value)
            q.breakable()
        q.text('}')

oxs.subtypes[2147615240] = oxs_idle_time

class oxs_packet_count(oxs):
    type_len = 2147616264

    def __init__(self, value=None):
        if value != None:
            self.value = value
        else:
            self.value = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!L", self.type_len))
        packed.append(struct.pack("!Q", self.value))
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = oxs_packet_count()
        _type_len = reader.read("!L")[0]
        assert(_type_len == 2147616264)
        obj.value = reader.read("!Q")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.value != other.value: return False
        return True

    def pretty_print(self, q):
        q.text("oxs_packet_count {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("value = ");
                q.text("%#x" % self.value)
            q.breakable()
        q.text('}')

oxs.subtypes[2147616264] = oxs_packet_count

class packet_queue(loxi.OFObject):

    def __init__(self, queue_id=None, port=None, properties=None):
        if queue_id != None:
            self.queue_id = queue_id
        else:
            self.queue_id = 0
        if port != None:
            self.port = port
        else:
            self.port = 0
        if properties != None:
            self.properties = properties
        else:
            self.properties = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!L", self.queue_id))
        packed.append(util.pack_port_no(self.port))
        packed.append(struct.pack("!H", 0)) # placeholder for len at index 2
        packed.append('\x00' * 6)
        packed.append(loxi.generic_util.pack_list(self.properties))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = packet_queue()
        obj.queue_id = reader.read("!L")[0]
        obj.port = util.unpack_port_no(reader)
        _len = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_len, 10)
        reader.skip(6)
        obj.properties = loxi.generic_util.unpack_list(reader, ofp.common.queue_prop.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.queue_id != other.queue_id: return False
        if self.port != other.port: return False
        if self.properties != other.properties: return False
        return True

    def pretty_print(self, q):
        q.text("packet_queue {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("queue_id = ");
                q.text("%#x" % self.queue_id)
                q.text(","); q.breakable()
                q.text("port = ");
                q.text(util.pretty_port(self.port))
                q.text(","); q.breakable()
                q.text("properties = ");
                q.pp(self.properties)
            q.breakable()
        q.text('}')


class port_desc(loxi.OFObject):

    def __init__(self, port_no=None, hw_addr=None, name=None, config=None, state=None, properties=None):
        if port_no != None:
            self.port_no = port_no
        else:
            self.port_no = 0
        if hw_addr != None:
            self.hw_addr = hw_addr
        else:
            self.hw_addr = [0,0,0,0,0,0]
        if name != None:
            self.name = name
        else:
            self.name = ""
        if config != None:
            self.config = config
        else:
            self.config = 0
        if state != None:
            self.state = state
        else:
            self.state = 0
        if properties != None:
            self.properties = properties
        else:
            self.properties = []
        return

    def pack(self):
        packed = []
        packed.append(util.pack_port_no(self.port_no))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append('\x00' * 2)
        packed.append(struct.pack("!6B", *self.hw_addr))
        packed.append('\x00' * 2)
        packed.append(struct.pack("!16s", self.name))
        packed.append(struct.pack("!L", self.config))
        packed.append(struct.pack("!L", self.state))
        packed.append(loxi.generic_util.pack_list(self.properties))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = port_desc()
        obj.port_no = util.unpack_port_no(reader)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 6)
        reader.skip(2)
        obj.hw_addr = list(reader.read('!6B'))
        reader.skip(2)
        obj.name = reader.read("!16s")[0].rstrip("\x00")
        obj.config = reader.read("!L")[0]
        obj.state = reader.read("!L")[0]
        obj.properties = loxi.generic_util.unpack_list(reader, ofp.port_desc_prop.port_desc_prop.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.port_no != other.port_no: return False
        if self.hw_addr != other.hw_addr: return False
        if self.name != other.name: return False
        if self.config != other.config: return False
        if self.state != other.state: return False
        if self.properties != other.properties: return False
        return True

    def pretty_print(self, q):
        q.text("port_desc {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("port_no = ");
                q.text(util.pretty_port(self.port_no))
                q.text(","); q.breakable()
                q.text("hw_addr = ");
                q.text(util.pretty_mac(self.hw_addr))
                q.text(","); q.breakable()
                q.text("name = ");
                q.pp(self.name)
                q.text(","); q.breakable()
                q.text("config = ");
                value_name_map = {1: 'OFPPC_PORT_DOWN', 4: 'OFPPC_NO_RECV', 32: 'OFPPC_NO_FWD', 64: 'OFPPC_NO_PACKET_IN', 2147483648: 'OFPPC_BSN_MIRROR_DEST'}
                q.text(util.pretty_flags(self.config, value_name_map.values()))
                q.text(","); q.breakable()
                q.text("state = ");
                value_name_map = {1: 'OFPPS_LINK_DOWN', 2: 'OFPPS_BLOCKED', 4: 'OFPPS_LIVE'}
                q.text(util.pretty_flags(self.state, value_name_map.values()))
                q.text(","); q.breakable()
                q.text("properties = ");
                q.pp(self.properties)
            q.breakable()
        q.text('}')


class port_desc_prop_egress(loxi.OFObject):
    type = 3

    def __init__(self, oxm_ids=None):
        if oxm_ids != None:
            self.oxm_ids = oxm_ids
        else:
            self.oxm_ids = ''
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(self.oxm_ids)
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = port_desc_prop_egress()
        _type = reader.read("!H")[0]
        assert(_type == 3)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.oxm_ids = str(reader.read_all())
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.oxm_ids != other.oxm_ids: return False
        return True

    def pretty_print(self, q):
        q.text("port_desc_prop_egress {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("oxm_ids = ");
                q.pp(self.oxm_ids)
            q.breakable()
        q.text('}')


class port_desc_prop_ingress(loxi.OFObject):
    type = 2

    def __init__(self, oxm_ids=None):
        if oxm_ids != None:
            self.oxm_ids = oxm_ids
        else:
            self.oxm_ids = ''
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(self.oxm_ids)
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = port_desc_prop_ingress()
        _type = reader.read("!H")[0]
        assert(_type == 2)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.oxm_ids = str(reader.read_all())
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.oxm_ids != other.oxm_ids: return False
        return True

    def pretty_print(self, q):
        q.text("port_desc_prop_ingress {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("oxm_ids = ");
                q.pp(self.oxm_ids)
            q.breakable()
        q.text('}')


class port_stats_entry(loxi.OFObject):

    def __init__(self, port_no=None, duration_sec=None, duration_nsec=None, rx_packets=None, tx_packets=None, rx_bytes=None, tx_bytes=None, rx_dropped=None, tx_dropped=None, rx_errors=None, tx_errors=None, properties=None):
        if port_no != None:
            self.port_no = port_no
        else:
            self.port_no = 0
        if duration_sec != None:
            self.duration_sec = duration_sec
        else:
            self.duration_sec = 0
        if duration_nsec != None:
            self.duration_nsec = duration_nsec
        else:
            self.duration_nsec = 0
        if rx_packets != None:
            self.rx_packets = rx_packets
        else:
            self.rx_packets = 0
        if tx_packets != None:
            self.tx_packets = tx_packets
        else:
            self.tx_packets = 0
        if rx_bytes != None:
            self.rx_bytes = rx_bytes
        else:
            self.rx_bytes = 0
        if tx_bytes != None:
            self.tx_bytes = tx_bytes
        else:
            self.tx_bytes = 0
        if rx_dropped != None:
            self.rx_dropped = rx_dropped
        else:
            self.rx_dropped = 0
        if tx_dropped != None:
            self.tx_dropped = tx_dropped
        else:
            self.tx_dropped = 0
        if rx_errors != None:
            self.rx_errors = rx_errors
        else:
            self.rx_errors = 0
        if tx_errors != None:
            self.tx_errors = tx_errors
        else:
            self.tx_errors = 0
        if properties != None:
            self.properties = properties
        else:
            self.properties = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 0
        packed.append('\x00' * 2)
        packed.append(util.pack_port_no(self.port_no))
        packed.append(struct.pack("!L", self.duration_sec))
        packed.append(struct.pack("!L", self.duration_nsec))
        packed.append(struct.pack("!Q", self.rx_packets))
        packed.append(struct.pack("!Q", self.tx_packets))
        packed.append(struct.pack("!Q", self.rx_bytes))
        packed.append(struct.pack("!Q", self.tx_bytes))
        packed.append(struct.pack("!Q", self.rx_dropped))
        packed.append(struct.pack("!Q", self.tx_dropped))
        packed.append(struct.pack("!Q", self.rx_errors))
        packed.append(struct.pack("!Q", self.tx_errors))
        packed.append(loxi.generic_util.pack_list(self.properties))
        length = sum([len(x) for x in packed])
        packed[0] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = port_stats_entry()
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 2)
        reader.skip(2)
        obj.port_no = util.unpack_port_no(reader)
        obj.duration_sec = reader.read("!L")[0]
        obj.duration_nsec = reader.read("!L")[0]
        obj.rx_packets = reader.read("!Q")[0]
        obj.tx_packets = reader.read("!Q")[0]
        obj.rx_bytes = reader.read("!Q")[0]
        obj.tx_bytes = reader.read("!Q")[0]
        obj.rx_dropped = reader.read("!Q")[0]
        obj.tx_dropped = reader.read("!Q")[0]
        obj.rx_errors = reader.read("!Q")[0]
        obj.tx_errors = reader.read("!Q")[0]
        obj.properties = loxi.generic_util.unpack_list(reader, ofp.port_stats_prop.port_stats_prop.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.port_no != other.port_no: return False
        if self.duration_sec != other.duration_sec: return False
        if self.duration_nsec != other.duration_nsec: return False
        if self.rx_packets != other.rx_packets: return False
        if self.tx_packets != other.tx_packets: return False
        if self.rx_bytes != other.rx_bytes: return False
        if self.tx_bytes != other.tx_bytes: return False
        if self.rx_dropped != other.rx_dropped: return False
        if self.tx_dropped != other.tx_dropped: return False
        if self.rx_errors != other.rx_errors: return False
        if self.tx_errors != other.tx_errors: return False
        if self.properties != other.properties: return False
        return True

    def pretty_print(self, q):
        q.text("port_stats_entry {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("port_no = ");
                q.text(util.pretty_port(self.port_no))
                q.text(","); q.breakable()
                q.text("duration_sec = ");
                q.text("%#x" % self.duration_sec)
                q.text(","); q.breakable()
                q.text("duration_nsec = ");
                q.text("%#x" % self.duration_nsec)
                q.text(","); q.breakable()
                q.text("rx_packets = ");
                q.text("%#x" % self.rx_packets)
                q.text(","); q.breakable()
                q.text("tx_packets = ");
                q.text("%#x" % self.tx_packets)
                q.text(","); q.breakable()
                q.text("rx_bytes = ");
                q.text("%#x" % self.rx_bytes)
                q.text(","); q.breakable()
                q.text("tx_bytes = ");
                q.text("%#x" % self.tx_bytes)
                q.text(","); q.breakable()
                q.text("rx_dropped = ");
                q.text("%#x" % self.rx_dropped)
                q.text(","); q.breakable()
                q.text("tx_dropped = ");
                q.text("%#x" % self.tx_dropped)
                q.text(","); q.breakable()
                q.text("rx_errors = ");
                q.text("%#x" % self.rx_errors)
                q.text(","); q.breakable()
                q.text("tx_errors = ");
                q.text("%#x" % self.tx_errors)
                q.text(","); q.breakable()
                q.text("properties = ");
                q.pp(self.properties)
            q.breakable()
        q.text('}')


class queue_desc(loxi.OFObject):

    def __init__(self, port_no=None, queue_id=None, properties=None):
        if port_no != None:
            self.port_no = port_no
        else:
            self.port_no = 0
        if queue_id != None:
            self.queue_id = queue_id
        else:
            self.queue_id = 0
        if properties != None:
            self.properties = properties
        else:
            self.properties = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!L", self.port_no))
        packed.append(struct.pack("!L", self.queue_id))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append('\x00' * 6)
        packed.append(loxi.generic_util.pack_list(self.properties))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = queue_desc()
        obj.port_no = reader.read("!L")[0]
        obj.queue_id = reader.read("!L")[0]
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 10)
        reader.skip(6)
        obj.properties = loxi.generic_util.unpack_list(reader, ofp.queue_desc_prop.queue_desc_prop.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.port_no != other.port_no: return False
        if self.queue_id != other.queue_id: return False
        if self.properties != other.properties: return False
        return True

    def pretty_print(self, q):
        q.text("queue_desc {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("port_no = ");
                q.text("%#x" % self.port_no)
                q.text(","); q.breakable()
                q.text("queue_id = ");
                q.text("%#x" % self.queue_id)
                q.text(","); q.breakable()
                q.text("properties = ");
                q.pp(self.properties)
            q.breakable()
        q.text('}')


class queue_prop(loxi.OFObject):
    subtypes = {}


    def __init__(self, type=None):
        if type != None:
            self.type = type
        else:
            self.type = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for len at index 1
        packed.append('\x00' * 4)
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        subtype, = reader.peek('!H', 0)
        subclass = queue_prop.subtypes.get(subtype)
        if subclass:
            return subclass.unpack(reader)

        obj = queue_prop()
        obj.type = reader.read("!H")[0]
        _len = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_len, 4)
        reader.skip(4)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.type != other.type: return False
        return True

    def pretty_print(self, q):
        q.text("queue_prop {")
        with q.group():
            with q.indent(2):
                q.breakable()
            q.breakable()
        q.text('}')


class queue_prop_experimenter(queue_prop):
    subtypes = {}

    type = 65535

    def __init__(self, experimenter=None, data=None):
        if experimenter != None:
            self.experimenter = experimenter
        else:
            self.experimenter = 0
        if data != None:
            self.data = data
        else:
            self.data = ''
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for len at index 1
        packed.append('\x00' * 4)
        packed.append(struct.pack("!L", self.experimenter))
        packed.append('\x00' * 4)
        packed.append(self.data)
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        subtype, = reader.peek('!L', 8)
        subclass = queue_prop_experimenter.subtypes.get(subtype)
        if subclass:
            return subclass.unpack(reader)

        obj = queue_prop_experimenter()
        _type = reader.read("!H")[0]
        assert(_type == 65535)
        _len = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_len, 4)
        reader.skip(4)
        obj.experimenter = reader.read("!L")[0]
        reader.skip(4)
        obj.data = str(reader.read_all())
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.experimenter != other.experimenter: return False
        if self.data != other.data: return False
        return True

    def pretty_print(self, q):
        q.text("queue_prop_experimenter {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("data = ");
                q.pp(self.data)
            q.breakable()
        q.text('}')

queue_prop.subtypes[65535] = queue_prop_experimenter

class queue_prop_max_rate(queue_prop):
    type = 2

    def __init__(self, rate=None):
        if rate != None:
            self.rate = rate
        else:
            self.rate = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for len at index 1
        packed.append('\x00' * 4)
        packed.append(struct.pack("!H", self.rate))
        packed.append('\x00' * 6)
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = queue_prop_max_rate()
        _type = reader.read("!H")[0]
        assert(_type == 2)
        _len = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_len, 4)
        reader.skip(4)
        obj.rate = reader.read("!H")[0]
        reader.skip(6)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.rate != other.rate: return False
        return True

    def pretty_print(self, q):
        q.text("queue_prop_max_rate {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("rate = ");
                q.text("%#x" % self.rate)
            q.breakable()
        q.text('}')

queue_prop.subtypes[2] = queue_prop_max_rate

class queue_prop_min_rate(queue_prop):
    type = 1

    def __init__(self, rate=None):
        if rate != None:
            self.rate = rate
        else:
            self.rate = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for len at index 1
        packed.append('\x00' * 4)
        packed.append(struct.pack("!H", self.rate))
        packed.append('\x00' * 6)
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = queue_prop_min_rate()
        _type = reader.read("!H")[0]
        assert(_type == 1)
        _len = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_len, 4)
        reader.skip(4)
        obj.rate = reader.read("!H")[0]
        reader.skip(6)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.rate != other.rate: return False
        return True

    def pretty_print(self, q):
        q.text("queue_prop_min_rate {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("rate = ");
                q.text("%#x" % self.rate)
            q.breakable()
        q.text('}')

queue_prop.subtypes[1] = queue_prop_min_rate

class queue_stats_entry(loxi.OFObject):

    def __init__(self, port_no=None, queue_id=None, tx_bytes=None, tx_packets=None, tx_errors=None, duration_sec=None, duration_nsec=None, properties=None):
        if port_no != None:
            self.port_no = port_no
        else:
            self.port_no = 0
        if queue_id != None:
            self.queue_id = queue_id
        else:
            self.queue_id = 0
        if tx_bytes != None:
            self.tx_bytes = tx_bytes
        else:
            self.tx_bytes = 0
        if tx_packets != None:
            self.tx_packets = tx_packets
        else:
            self.tx_packets = 0
        if tx_errors != None:
            self.tx_errors = tx_errors
        else:
            self.tx_errors = 0
        if duration_sec != None:
            self.duration_sec = duration_sec
        else:
            self.duration_sec = 0
        if duration_nsec != None:
            self.duration_nsec = duration_nsec
        else:
            self.duration_nsec = 0
        if properties != None:
            self.properties = properties
        else:
            self.properties = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 0
        packed.append('\x00' * 6)
        packed.append(util.pack_port_no(self.port_no))
        packed.append(struct.pack("!L", self.queue_id))
        packed.append(struct.pack("!Q", self.tx_bytes))
        packed.append(struct.pack("!Q", self.tx_packets))
        packed.append(struct.pack("!Q", self.tx_errors))
        packed.append(struct.pack("!L", self.duration_sec))
        packed.append(struct.pack("!L", self.duration_nsec))
        packed.append(loxi.generic_util.pack_list(self.properties))
        length = sum([len(x) for x in packed])
        packed[0] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = queue_stats_entry()
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 2)
        reader.skip(6)
        obj.port_no = util.unpack_port_no(reader)
        obj.queue_id = reader.read("!L")[0]
        obj.tx_bytes = reader.read("!Q")[0]
        obj.tx_packets = reader.read("!Q")[0]
        obj.tx_errors = reader.read("!Q")[0]
        obj.duration_sec = reader.read("!L")[0]
        obj.duration_nsec = reader.read("!L")[0]
        obj.properties = loxi.generic_util.unpack_list(reader, ofp.queue_stats_prop.queue_stats_prop.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.port_no != other.port_no: return False
        if self.queue_id != other.queue_id: return False
        if self.tx_bytes != other.tx_bytes: return False
        if self.tx_packets != other.tx_packets: return False
        if self.tx_errors != other.tx_errors: return False
        if self.duration_sec != other.duration_sec: return False
        if self.duration_nsec != other.duration_nsec: return False
        if self.properties != other.properties: return False
        return True

    def pretty_print(self, q):
        q.text("queue_stats_entry {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("port_no = ");
                q.text(util.pretty_port(self.port_no))
                q.text(","); q.breakable()
                q.text("queue_id = ");
                q.text("%#x" % self.queue_id)
                q.text(","); q.breakable()
                q.text("tx_bytes = ");
                q.text("%#x" % self.tx_bytes)
                q.text(","); q.breakable()
                q.text("tx_packets = ");
                q.text("%#x" % self.tx_packets)
                q.text(","); q.breakable()
                q.text("tx_errors = ");
                q.text("%#x" % self.tx_errors)
                q.text(","); q.breakable()
                q.text("duration_sec = ");
                q.text("%#x" % self.duration_sec)
                q.text(","); q.breakable()
                q.text("duration_nsec = ");
                q.text("%#x" % self.duration_nsec)
                q.text(","); q.breakable()
                q.text("properties = ");
                q.pp(self.properties)
            q.breakable()
        q.text('}')


class stat_v6(loxi.OFObject):

    def __init__(self, oxs_fields=None):
        if oxs_fields != None:
            self.oxs_fields = oxs_fields
        else:
            self.oxs_fields = []
        return

    def pack(self):
        packed = []
        packed.append('\x00' * 2)
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(loxi.generic_util.pack_list(self.oxs_fields))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        packed.append(loxi.generic_util.pad_to(8, length))
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = stat_v6()
        reader.skip(2)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.oxs_fields = loxi.generic_util.unpack_list(reader, ofp.common.oxs.unpack)
        orig_reader.skip_align()
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.oxs_fields != other.oxs_fields: return False
        return True

    def pretty_print(self, q):
        q.text("stat_v6 {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("oxs_fields = ");
                q.pp(self.oxs_fields)
            q.breakable()
        q.text('}')


class table_desc(loxi.OFObject):

    def __init__(self, table_id=None, config=None, properties=None):
        if table_id != None:
            self.table_id = table_id
        else:
            self.table_id = 0
        if config != None:
            self.config = config
        else:
            self.config = 0
        if properties != None:
            self.properties = properties
        else:
            self.properties = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 0
        packed.append(struct.pack("!B", self.table_id))
        packed.append('\x00' * 1)
        packed.append(struct.pack("!L", self.config))
        packed.append(loxi.generic_util.pack_list(self.properties))
        length = sum([len(x) for x in packed])
        packed[0] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = table_desc()
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 2)
        obj.table_id = reader.read("!B")[0]
        reader.skip(1)
        obj.config = reader.read("!L")[0]
        obj.properties = loxi.generic_util.unpack_list(reader, ofp.table_mod_prop.table_mod_prop.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.table_id != other.table_id: return False
        if self.config != other.config: return False
        if self.properties != other.properties: return False
        return True

    def pretty_print(self, q):
        q.text("table_desc {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("table_id = ");
                q.text("%#x" % self.table_id)
                q.text(","); q.breakable()
                q.text("config = ");
                value_name_map = {3: 'OFPTC_DEPRECATED_MASK', 4: 'OFPTC_EVICTION', 8: 'OFPTC_VACANCY_EVENTS'}
                q.text(util.pretty_flags(self.config, value_name_map.values()))
                q.text(","); q.breakable()
                q.text("properties = ");
                q.pp(self.properties)
            q.breakable()
        q.text('}')


class table_feature_prop(loxi.OFObject):
    subtypes = {}


    def __init__(self, type=None):
        if type != None:
            self.type = type
        else:
            self.type = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        subtype, = reader.peek('!H', 0)
        subclass = table_feature_prop.subtypes.get(subtype)
        if subclass:
            return subclass.unpack(reader)

        obj = table_feature_prop()
        obj.type = reader.read("!H")[0]
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.type != other.type: return False
        return True

    def pretty_print(self, q):
        q.text("table_feature_prop {")
        with q.group():
            with q.indent(2):
                q.breakable()
            q.breakable()
        q.text('}')


class table_feature_prop_apply_actions(table_feature_prop):
    type = 6

    def __init__(self, action_ids=None):
        if action_ids != None:
            self.action_ids = action_ids
        else:
            self.action_ids = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(loxi.generic_util.pack_list(self.action_ids))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = table_feature_prop_apply_actions()
        _type = reader.read("!H")[0]
        assert(_type == 6)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.action_ids = loxi.generic_util.unpack_list(reader, ofp.action_id.action_id.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.action_ids != other.action_ids: return False
        return True

    def pretty_print(self, q):
        q.text("table_feature_prop_apply_actions {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("action_ids = ");
                q.pp(self.action_ids)
            q.breakable()
        q.text('}')

table_feature_prop.subtypes[6] = table_feature_prop_apply_actions

class table_feature_prop_apply_actions_miss(table_feature_prop):
    type = 7

    def __init__(self, action_ids=None):
        if action_ids != None:
            self.action_ids = action_ids
        else:
            self.action_ids = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(loxi.generic_util.pack_list(self.action_ids))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = table_feature_prop_apply_actions_miss()
        _type = reader.read("!H")[0]
        assert(_type == 7)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.action_ids = loxi.generic_util.unpack_list(reader, ofp.action_id.action_id.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.action_ids != other.action_ids: return False
        return True

    def pretty_print(self, q):
        q.text("table_feature_prop_apply_actions_miss {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("action_ids = ");
                q.pp(self.action_ids)
            q.breakable()
        q.text('}')

table_feature_prop.subtypes[7] = table_feature_prop_apply_actions_miss

class table_feature_prop_apply_copyfield(table_feature_prop):
    type = 20

    def __init__(self, oxm_ids=None):
        if oxm_ids != None:
            self.oxm_ids = oxm_ids
        else:
            self.oxm_ids = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(loxi.generic_util.pack_list(self.oxm_ids))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = table_feature_prop_apply_copyfield()
        _type = reader.read("!H")[0]
        assert(_type == 20)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.oxm_ids = loxi.generic_util.unpack_list(reader, ofp.common.uint32.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.oxm_ids != other.oxm_ids: return False
        return True

    def pretty_print(self, q):
        q.text("table_feature_prop_apply_copyfield {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("oxm_ids = ");
                q.pp(self.oxm_ids)
            q.breakable()
        q.text('}')

table_feature_prop.subtypes[20] = table_feature_prop_apply_copyfield

class table_feature_prop_apply_copyfield_miss(table_feature_prop):
    type = 21

    def __init__(self, oxm_ids=None):
        if oxm_ids != None:
            self.oxm_ids = oxm_ids
        else:
            self.oxm_ids = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(loxi.generic_util.pack_list(self.oxm_ids))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = table_feature_prop_apply_copyfield_miss()
        _type = reader.read("!H")[0]
        assert(_type == 21)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.oxm_ids = loxi.generic_util.unpack_list(reader, ofp.common.uint32.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.oxm_ids != other.oxm_ids: return False
        return True

    def pretty_print(self, q):
        q.text("table_feature_prop_apply_copyfield_miss {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("oxm_ids = ");
                q.pp(self.oxm_ids)
            q.breakable()
        q.text('}')

table_feature_prop.subtypes[21] = table_feature_prop_apply_copyfield_miss

class table_feature_prop_apply_setfield(table_feature_prop):
    type = 14

    def __init__(self, oxm_ids=None):
        if oxm_ids != None:
            self.oxm_ids = oxm_ids
        else:
            self.oxm_ids = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(loxi.generic_util.pack_list(self.oxm_ids))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = table_feature_prop_apply_setfield()
        _type = reader.read("!H")[0]
        assert(_type == 14)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.oxm_ids = loxi.generic_util.unpack_list(reader, ofp.common.uint32.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.oxm_ids != other.oxm_ids: return False
        return True

    def pretty_print(self, q):
        q.text("table_feature_prop_apply_setfield {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("oxm_ids = ");
                q.pp(self.oxm_ids)
            q.breakable()
        q.text('}')

table_feature_prop.subtypes[14] = table_feature_prop_apply_setfield

class table_feature_prop_apply_setfield_miss(table_feature_prop):
    type = 15

    def __init__(self, oxm_ids=None):
        if oxm_ids != None:
            self.oxm_ids = oxm_ids
        else:
            self.oxm_ids = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(loxi.generic_util.pack_list(self.oxm_ids))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = table_feature_prop_apply_setfield_miss()
        _type = reader.read("!H")[0]
        assert(_type == 15)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.oxm_ids = loxi.generic_util.unpack_list(reader, ofp.common.uint32.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.oxm_ids != other.oxm_ids: return False
        return True

    def pretty_print(self, q):
        q.text("table_feature_prop_apply_setfield_miss {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("oxm_ids = ");
                q.pp(self.oxm_ids)
            q.breakable()
        q.text('}')

table_feature_prop.subtypes[15] = table_feature_prop_apply_setfield_miss

class table_feature_prop_experimenter(table_feature_prop):
    subtypes = {}

    type = 65534

    def __init__(self, experimenter=None, subtype=None):
        if experimenter != None:
            self.experimenter = experimenter
        else:
            self.experimenter = 0
        if subtype != None:
            self.subtype = subtype
        else:
            self.subtype = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(struct.pack("!L", self.experimenter))
        packed.append(struct.pack("!L", self.subtype))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        subtype, = reader.peek('!L', 4)
        subclass = table_feature_prop_experimenter.subtypes.get(subtype)
        if subclass:
            return subclass.unpack(reader)

        obj = table_feature_prop_experimenter()
        _type = reader.read("!H")[0]
        assert(_type == 65534)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.experimenter = reader.read("!L")[0]
        obj.subtype = reader.read("!L")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.experimenter != other.experimenter: return False
        if self.subtype != other.subtype: return False
        return True

    def pretty_print(self, q):
        q.text("table_feature_prop_experimenter {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("subtype = ");
                q.text("%#x" % self.subtype)
            q.breakable()
        q.text('}')

table_feature_prop.subtypes[65534] = table_feature_prop_experimenter

class table_feature_prop_experimenter_miss(table_feature_prop):
    subtypes = {}

    type = 65535

    def __init__(self, experimenter=None, subtype=None):
        if experimenter != None:
            self.experimenter = experimenter
        else:
            self.experimenter = 0
        if subtype != None:
            self.subtype = subtype
        else:
            self.subtype = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(struct.pack("!L", self.experimenter))
        packed.append(struct.pack("!L", self.subtype))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        subtype, = reader.peek('!L', 4)
        subclass = table_feature_prop_experimenter_miss.subtypes.get(subtype)
        if subclass:
            return subclass.unpack(reader)

        obj = table_feature_prop_experimenter_miss()
        _type = reader.read("!H")[0]
        assert(_type == 65535)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.experimenter = reader.read("!L")[0]
        obj.subtype = reader.read("!L")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.experimenter != other.experimenter: return False
        if self.subtype != other.subtype: return False
        return True

    def pretty_print(self, q):
        q.text("table_feature_prop_experimenter_miss {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("subtype = ");
                q.text("%#x" % self.subtype)
            q.breakable()
        q.text('}')

table_feature_prop.subtypes[65535] = table_feature_prop_experimenter_miss

class table_feature_prop_instructions(table_feature_prop):
    type = 0

    def __init__(self, instruction_ids=None):
        if instruction_ids != None:
            self.instruction_ids = instruction_ids
        else:
            self.instruction_ids = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(loxi.generic_util.pack_list(self.instruction_ids))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = table_feature_prop_instructions()
        _type = reader.read("!H")[0]
        assert(_type == 0)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.instruction_ids = loxi.generic_util.unpack_list(reader, ofp.instruction_id.instruction_id.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.instruction_ids != other.instruction_ids: return False
        return True

    def pretty_print(self, q):
        q.text("table_feature_prop_instructions {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("instruction_ids = ");
                q.pp(self.instruction_ids)
            q.breakable()
        q.text('}')

table_feature_prop.subtypes[0] = table_feature_prop_instructions

class table_feature_prop_instructions_miss(table_feature_prop):
    type = 1

    def __init__(self, instruction_ids=None):
        if instruction_ids != None:
            self.instruction_ids = instruction_ids
        else:
            self.instruction_ids = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(loxi.generic_util.pack_list(self.instruction_ids))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = table_feature_prop_instructions_miss()
        _type = reader.read("!H")[0]
        assert(_type == 1)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.instruction_ids = loxi.generic_util.unpack_list(reader, ofp.instruction_id.instruction_id.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.instruction_ids != other.instruction_ids: return False
        return True

    def pretty_print(self, q):
        q.text("table_feature_prop_instructions_miss {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("instruction_ids = ");
                q.pp(self.instruction_ids)
            q.breakable()
        q.text('}')

table_feature_prop.subtypes[1] = table_feature_prop_instructions_miss

class table_feature_prop_match(table_feature_prop):
    type = 8

    def __init__(self, oxm_ids=None):
        if oxm_ids != None:
            self.oxm_ids = oxm_ids
        else:
            self.oxm_ids = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(loxi.generic_util.pack_list(self.oxm_ids))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = table_feature_prop_match()
        _type = reader.read("!H")[0]
        assert(_type == 8)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.oxm_ids = loxi.generic_util.unpack_list(reader, ofp.common.uint32.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.oxm_ids != other.oxm_ids: return False
        return True

    def pretty_print(self, q):
        q.text("table_feature_prop_match {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("oxm_ids = ");
                q.pp(self.oxm_ids)
            q.breakable()
        q.text('}')

table_feature_prop.subtypes[8] = table_feature_prop_match

class table_feature_prop_next_tables(table_feature_prop):
    type = 2

    def __init__(self, next_table_ids=None):
        if next_table_ids != None:
            self.next_table_ids = next_table_ids
        else:
            self.next_table_ids = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(loxi.generic_util.pack_list(self.next_table_ids))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = table_feature_prop_next_tables()
        _type = reader.read("!H")[0]
        assert(_type == 2)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.next_table_ids = loxi.generic_util.unpack_list(reader, ofp.common.uint8.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.next_table_ids != other.next_table_ids: return False
        return True

    def pretty_print(self, q):
        q.text("table_feature_prop_next_tables {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("next_table_ids = ");
                q.pp(self.next_table_ids)
            q.breakable()
        q.text('}')

table_feature_prop.subtypes[2] = table_feature_prop_next_tables

class table_feature_prop_next_tables_miss(table_feature_prop):
    type = 3

    def __init__(self, next_table_ids=None):
        if next_table_ids != None:
            self.next_table_ids = next_table_ids
        else:
            self.next_table_ids = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(loxi.generic_util.pack_list(self.next_table_ids))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = table_feature_prop_next_tables_miss()
        _type = reader.read("!H")[0]
        assert(_type == 3)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.next_table_ids = loxi.generic_util.unpack_list(reader, ofp.common.uint8.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.next_table_ids != other.next_table_ids: return False
        return True

    def pretty_print(self, q):
        q.text("table_feature_prop_next_tables_miss {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("next_table_ids = ");
                q.pp(self.next_table_ids)
            q.breakable()
        q.text('}')

table_feature_prop.subtypes[3] = table_feature_prop_next_tables_miss

class table_feature_prop_oxm_values(loxi.OFObject):
    type = 22

    def __init__(self, oxm_values=None):
        if oxm_values != None:
            self.oxm_values = oxm_values
        else:
            self.oxm_values = ''
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(self.oxm_values)
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = table_feature_prop_oxm_values()
        _type = reader.read("!H")[0]
        assert(_type == 22)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.oxm_values = str(reader.read_all())
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.oxm_values != other.oxm_values: return False
        return True

    def pretty_print(self, q):
        q.text("table_feature_prop_oxm_values {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("oxm_values = ");
                q.pp(self.oxm_values)
            q.breakable()
        q.text('}')


class table_feature_prop_table_sync_from(table_feature_prop):
    type = 16

    def __init__(self, table_ids=None):
        if table_ids != None:
            self.table_ids = table_ids
        else:
            self.table_ids = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(loxi.generic_util.pack_list(self.table_ids))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = table_feature_prop_table_sync_from()
        _type = reader.read("!H")[0]
        assert(_type == 16)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.table_ids = loxi.generic_util.unpack_list(reader, ofp.common.uint8.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.table_ids != other.table_ids: return False
        return True

    def pretty_print(self, q):
        q.text("table_feature_prop_table_sync_from {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("table_ids = ");
                q.pp(self.table_ids)
            q.breakable()
        q.text('}')

table_feature_prop.subtypes[16] = table_feature_prop_table_sync_from

class table_feature_prop_wildcards(table_feature_prop):
    type = 10

    def __init__(self, oxm_ids=None):
        if oxm_ids != None:
            self.oxm_ids = oxm_ids
        else:
            self.oxm_ids = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(loxi.generic_util.pack_list(self.oxm_ids))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = table_feature_prop_wildcards()
        _type = reader.read("!H")[0]
        assert(_type == 10)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.oxm_ids = loxi.generic_util.unpack_list(reader, ofp.common.uint32.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.oxm_ids != other.oxm_ids: return False
        return True

    def pretty_print(self, q):
        q.text("table_feature_prop_wildcards {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("oxm_ids = ");
                q.pp(self.oxm_ids)
            q.breakable()
        q.text('}')

table_feature_prop.subtypes[10] = table_feature_prop_wildcards

class table_feature_prop_write_actions(table_feature_prop):
    type = 4

    def __init__(self, action_ids=None):
        if action_ids != None:
            self.action_ids = action_ids
        else:
            self.action_ids = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(loxi.generic_util.pack_list(self.action_ids))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = table_feature_prop_write_actions()
        _type = reader.read("!H")[0]
        assert(_type == 4)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.action_ids = loxi.generic_util.unpack_list(reader, ofp.action_id.action_id.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.action_ids != other.action_ids: return False
        return True

    def pretty_print(self, q):
        q.text("table_feature_prop_write_actions {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("action_ids = ");
                q.pp(self.action_ids)
            q.breakable()
        q.text('}')

table_feature_prop.subtypes[4] = table_feature_prop_write_actions

class table_feature_prop_write_actions_miss(table_feature_prop):
    type = 5

    def __init__(self, action_ids=None):
        if action_ids != None:
            self.action_ids = action_ids
        else:
            self.action_ids = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(loxi.generic_util.pack_list(self.action_ids))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = table_feature_prop_write_actions_miss()
        _type = reader.read("!H")[0]
        assert(_type == 5)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.action_ids = loxi.generic_util.unpack_list(reader, ofp.action_id.action_id.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.action_ids != other.action_ids: return False
        return True

    def pretty_print(self, q):
        q.text("table_feature_prop_write_actions_miss {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("action_ids = ");
                q.pp(self.action_ids)
            q.breakable()
        q.text('}')

table_feature_prop.subtypes[5] = table_feature_prop_write_actions_miss

class table_feature_prop_write_copyfield(table_feature_prop):
    type = 18

    def __init__(self, oxm_ids=None):
        if oxm_ids != None:
            self.oxm_ids = oxm_ids
        else:
            self.oxm_ids = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(loxi.generic_util.pack_list(self.oxm_ids))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = table_feature_prop_write_copyfield()
        _type = reader.read("!H")[0]
        assert(_type == 18)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.oxm_ids = loxi.generic_util.unpack_list(reader, ofp.common.uint32.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.oxm_ids != other.oxm_ids: return False
        return True

    def pretty_print(self, q):
        q.text("table_feature_prop_write_copyfield {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("oxm_ids = ");
                q.pp(self.oxm_ids)
            q.breakable()
        q.text('}')

table_feature_prop.subtypes[18] = table_feature_prop_write_copyfield

class table_feature_prop_write_copyfield_miss(table_feature_prop):
    type = 19

    def __init__(self, oxm_ids=None):
        if oxm_ids != None:
            self.oxm_ids = oxm_ids
        else:
            self.oxm_ids = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(loxi.generic_util.pack_list(self.oxm_ids))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = table_feature_prop_write_copyfield_miss()
        _type = reader.read("!H")[0]
        assert(_type == 19)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.oxm_ids = loxi.generic_util.unpack_list(reader, ofp.common.uint32.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.oxm_ids != other.oxm_ids: return False
        return True

    def pretty_print(self, q):
        q.text("table_feature_prop_write_copyfield_miss {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("oxm_ids = ");
                q.pp(self.oxm_ids)
            q.breakable()
        q.text('}')

table_feature_prop.subtypes[19] = table_feature_prop_write_copyfield_miss

class table_feature_prop_write_setfield(table_feature_prop):
    type = 12

    def __init__(self, oxm_ids=None):
        if oxm_ids != None:
            self.oxm_ids = oxm_ids
        else:
            self.oxm_ids = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(loxi.generic_util.pack_list(self.oxm_ids))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = table_feature_prop_write_setfield()
        _type = reader.read("!H")[0]
        assert(_type == 12)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.oxm_ids = loxi.generic_util.unpack_list(reader, ofp.common.uint32.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.oxm_ids != other.oxm_ids: return False
        return True

    def pretty_print(self, q):
        q.text("table_feature_prop_write_setfield {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("oxm_ids = ");
                q.pp(self.oxm_ids)
            q.breakable()
        q.text('}')

table_feature_prop.subtypes[12] = table_feature_prop_write_setfield

class table_feature_prop_write_setfield_miss(table_feature_prop):
    type = 13

    def __init__(self, oxm_ids=None):
        if oxm_ids != None:
            self.oxm_ids = oxm_ids
        else:
            self.oxm_ids = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(loxi.generic_util.pack_list(self.oxm_ids))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = table_feature_prop_write_setfield_miss()
        _type = reader.read("!H")[0]
        assert(_type == 13)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.oxm_ids = loxi.generic_util.unpack_list(reader, ofp.common.uint32.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.oxm_ids != other.oxm_ids: return False
        return True

    def pretty_print(self, q):
        q.text("table_feature_prop_write_setfield_miss {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("oxm_ids = ");
                q.pp(self.oxm_ids)
            q.breakable()
        q.text('}')

table_feature_prop.subtypes[13] = table_feature_prop_write_setfield_miss

class table_features(loxi.OFObject):

    def __init__(self, table_id=None, command=None, features=None, name=None, metadata_match=None, metadata_write=None, capabilities=None, max_entries=None, properties=None):
        if table_id != None:
            self.table_id = table_id
        else:
            self.table_id = 0
        if command != None:
            self.command = command
        else:
            self.command = 0
        if features != None:
            self.features = features
        else:
            self.features = 0
        if name != None:
            self.name = name
        else:
            self.name = ""
        if metadata_match != None:
            self.metadata_match = metadata_match
        else:
            self.metadata_match = 0
        if metadata_write != None:
            self.metadata_write = metadata_write
        else:
            self.metadata_write = 0
        if capabilities != None:
            self.capabilities = capabilities
        else:
            self.capabilities = 0
        if max_entries != None:
            self.max_entries = max_entries
        else:
            self.max_entries = 0
        if properties != None:
            self.properties = properties
        else:
            self.properties = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 0
        packed.append(struct.pack("!B", self.table_id))
        packed.append(struct.pack("!B", self.command))
        packed.append(struct.pack("!L", self.features))
        packed.append(struct.pack("!32s", self.name))
        packed.append(struct.pack("!Q", self.metadata_match))
        packed.append(struct.pack("!Q", self.metadata_write))
        packed.append(struct.pack("!L", self.capabilities))
        packed.append(struct.pack("!L", self.max_entries))
        packed.append(loxi.generic_util.pack_list(self.properties))
        length = sum([len(x) for x in packed])
        packed[0] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = table_features()
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 2)
        obj.table_id = reader.read("!B")[0]
        obj.command = reader.read("!B")[0]
        obj.features = reader.read("!L")[0]
        obj.name = reader.read("!32s")[0].rstrip("\x00")
        obj.metadata_match = reader.read("!Q")[0]
        obj.metadata_write = reader.read("!Q")[0]
        obj.capabilities = reader.read("!L")[0]
        obj.max_entries = reader.read("!L")[0]
        obj.properties = loxi.generic_util.unpack_list(reader, ofp.common.table_feature_prop.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.table_id != other.table_id: return False
        if self.command != other.command: return False
        if self.features != other.features: return False
        if self.name != other.name: return False
        if self.metadata_match != other.metadata_match: return False
        if self.metadata_write != other.metadata_write: return False
        if self.capabilities != other.capabilities: return False
        if self.max_entries != other.max_entries: return False
        if self.properties != other.properties: return False
        return True

    def pretty_print(self, q):
        q.text("table_features {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("table_id = ");
                q.text("%#x" % self.table_id)
                q.text(","); q.breakable()
                q.text("command = ");
                value_name_map = {0: 'OFPTFC_REPLACE', 1: 'OFPTFC_MODIFY', 2: 'OFPTFC_ENABLE', 3: 'OFPTFC_DISABLE'}
                if self.command in value_name_map:
                    q.text("%s(%d)" % (value_name_map[self.command], self.command))
                else:
                    q.text("%#x" % self.command)
                q.text(","); q.breakable()
                q.text("features = ");
                value_name_map = {1: 'OFPTFF_INGRESS_TABLE', 2: 'OFPTFF_EGRESS_TABLE', 16: 'OFPTFF_FIRST_EGRESS'}
                q.text(util.pretty_flags(self.features, value_name_map.values()))
                q.text(","); q.breakable()
                q.text("name = ");
                q.pp(self.name)
                q.text(","); q.breakable()
                q.text("metadata_match = ");
                q.text("%#x" % self.metadata_match)
                q.text(","); q.breakable()
                q.text("metadata_write = ");
                q.text("%#x" % self.metadata_write)
                q.text(","); q.breakable()
                q.text("capabilities = ");
                value_name_map = {3: 'OFPTC_DEPRECATED_MASK', 4: 'OFPTC_EVICTION', 8: 'OFPTC_VACANCY_EVENTS'}
                q.text(util.pretty_flags(self.capabilities, value_name_map.values()))
                q.text(","); q.breakable()
                q.text("max_entries = ");
                q.text("%#x" % self.max_entries)
                q.text(","); q.breakable()
                q.text("properties = ");
                q.pp(self.properties)
            q.breakable()
        q.text('}')


class table_stats_entry(loxi.OFObject):

    def __init__(self, table_id=None, active_count=None, lookup_count=None, matched_count=None):
        if table_id != None:
            self.table_id = table_id
        else:
            self.table_id = 0
        if active_count != None:
            self.active_count = active_count
        else:
            self.active_count = 0
        if lookup_count != None:
            self.lookup_count = lookup_count
        else:
            self.lookup_count = 0
        if matched_count != None:
            self.matched_count = matched_count
        else:
            self.matched_count = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.table_id))
        packed.append('\x00' * 3)
        packed.append(struct.pack("!L", self.active_count))
        packed.append(struct.pack("!Q", self.lookup_count))
        packed.append(struct.pack("!Q", self.matched_count))
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = table_stats_entry()
        obj.table_id = reader.read("!B")[0]
        reader.skip(3)
        obj.active_count = reader.read("!L")[0]
        obj.lookup_count = reader.read("!Q")[0]
        obj.matched_count = reader.read("!Q")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.table_id != other.table_id: return False
        if self.active_count != other.active_count: return False
        if self.lookup_count != other.lookup_count: return False
        if self.matched_count != other.matched_count: return False
        return True

    def pretty_print(self, q):
        q.text("table_stats_entry {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("table_id = ");
                q.text("%#x" % self.table_id)
                q.text(","); q.breakable()
                q.text("active_count = ");
                q.text("%#x" % self.active_count)
                q.text(","); q.breakable()
                q.text("lookup_count = ");
                q.text("%#x" % self.lookup_count)
                q.text(","); q.breakable()
                q.text("matched_count = ");
                q.text("%#x" % self.matched_count)
            q.breakable()
        q.text('}')


class uint32(loxi.OFObject):

    def __init__(self, value=None):
        if value != None:
            self.value = value
        else:
            self.value = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!L", self.value))
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = uint32()
        obj.value = reader.read("!L")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.value != other.value: return False
        return True

    def pretty_print(self, q):
        q.text("uint32 {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("value = ");
                q.text("%#x" % self.value)
            q.breakable()
        q.text('}')


class uint64(loxi.OFObject):

    def __init__(self, value=None):
        if value != None:
            self.value = value
        else:
            self.value = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!Q", self.value))
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = uint64()
        obj.value = reader.read("!Q")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.value != other.value: return False
        return True

    def pretty_print(self, q):
        q.text("uint64 {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("value = ");
                q.text("%#x" % self.value)
            q.breakable()
        q.text('}')


class uint8(loxi.OFObject):

    def __init__(self, value=None):
        if value != None:
            self.value = value
        else:
            self.value = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.value))
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = uint8()
        obj.value = reader.read("!B")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.value != other.value: return False
        return True

    def pretty_print(self, q):
        q.text("uint8 {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("value = ");
                q.text("%#x" % self.value)
            q.breakable()
        q.text('}')


class _action_copy_field(loxi.OFObject):
    type = 28

    def __init__(self, n_bits=None, src_offset=None, dst_offset=None, oxm_ids=None):
        if n_bits != None:
            self.n_bits = n_bits
        else:
            self.n_bits = 0
        if src_offset != None:
            self.src_offset = src_offset
        else:
            self.src_offset = 0
        if dst_offset != None:
            self.dst_offset = dst_offset
        else:
            self.dst_offset = 0
        if oxm_ids != None:
            self.oxm_ids = oxm_ids
        else:
            self.oxm_ids = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for len at index 1
        packed.append(struct.pack("!H", self.n_bits))
        packed.append(struct.pack("!H", self.src_offset))
        packed.append(struct.pack("!H", self.dst_offset))
        packed.append('\x00' * 2)
        packed.append(loxi.generic_util.pack_list(self.oxm_ids))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = _action_copy_field()
        _type = reader.read("!H")[0]
        assert(_type == 28)
        _len = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_len, 4)
        obj.n_bits = reader.read("!H")[0]
        obj.src_offset = reader.read("!H")[0]
        obj.dst_offset = reader.read("!H")[0]
        reader.skip(2)
        obj.oxm_ids = loxi.generic_util.unpack_list(reader, ofp.oxm.oxm.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.n_bits != other.n_bits: return False
        if self.src_offset != other.src_offset: return False
        if self.dst_offset != other.dst_offset: return False
        if self.oxm_ids != other.oxm_ids: return False
        return True

    def pretty_print(self, q):
        q.text("_action_copy_field {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("n_bits = ");
                q.text("%#x" % self.n_bits)
                q.text(","); q.breakable()
                q.text("src_offset = ");
                q.text("%#x" % self.src_offset)
                q.text(","); q.breakable()
                q.text("dst_offset = ");
                q.text("%#x" % self.dst_offset)
                q.text(","); q.breakable()
                q.text("oxm_ids = ");
                q.pp(self.oxm_ids)
            q.breakable()
        q.text('}')


class _controller_status_prop_experimenter(controller_status_prop):
    subtypes = {}

    type = 65535

    def __init__(self, experimenter=None, exp_type=None):
        if experimenter != None:
            self.experimenter = experimenter
        else:
            self.experimenter = 0
        if exp_type != None:
            self.exp_type = exp_type
        else:
            self.exp_type = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(struct.pack("!L", self.experimenter))
        packed.append(struct.pack("!L", self.exp_type))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        subtype, = reader.peek('!L', 4)
        subclass = _controller_status_prop_experimenter.subtypes.get(subtype)
        if subclass:
            return subclass.unpack(reader)

        obj = _controller_status_prop_experimenter()
        _type = reader.read("!H")[0]
        assert(_type == 65535)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.experimenter = reader.read("!L")[0]
        obj.exp_type = reader.read("!L")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.experimenter != other.experimenter: return False
        if self.exp_type != other.exp_type: return False
        return True

    def pretty_print(self, q):
        q.text("_controller_status_prop_experimenter {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("exp_type = ");
                q.text("%#x" % self.exp_type)
            q.breakable()
        q.text('}')

controller_status_prop.subtypes[65535] = _controller_status_prop_experimenter

class _controller_status_prop_uri(controller_status_prop):
    type = 0

    def __init__(self, uri=None):
        if uri != None:
            self.uri = uri
        else:
            self.uri = loxi.unimplemented('init of_controller_uri_t')
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(loxi.unimplemented('pack of_controller_uri_t'))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = _controller_status_prop_uri()
        _type = reader.read("!H")[0]
        assert(_type == 0)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.uri = loxi.unimplemented('unpack of_controller_uri_t')
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.uri != other.uri: return False
        return True

    def pretty_print(self, q):
        q.text("_controller_status_prop_uri {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("uri = ");
                q.pp(self.uri)
            q.breakable()
        q.text('}')

controller_status_prop.subtypes[0] = _controller_status_prop_uri

class _port_desc_prop_recirculate(loxi.OFObject):
    type = 4

    def __init__(self, port_nos=None):
        if port_nos != None:
            self.port_nos = port_nos
        else:
            self.port_nos = ''
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(self.port_nos)
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = _port_desc_prop_recirculate()
        _type = reader.read("!H")[0]
        assert(_type == 4)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.port_nos = str(reader.read_all())
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.port_nos != other.port_nos: return False
        return True

    def pretty_print(self, q):
        q.text("_port_desc_prop_recirculate {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("port_nos = ");
                q.pp(self.port_nos)
            q.breakable()
        q.text('}')



match = match_v3
stat = stat_v6
