# Copyright (c) 2008 The Board of Trustees of The Leland Stanford Junior University
# Copyright (c) 2011, 2012 Open Networking Foundation
# Copyright (c) 2012, 2013 Big Switch Networks, Inc.
# See the file LICENSE.pyloxi which should have been included in the source distribution

# Automatically generated by LOXI from template module.py
# Do not modify

import struct
import loxi
from . import util
import loxi.generic_util

import sys
ofp = sys.modules['loxi.of15']

class table_mod_prop(loxi.OFObject):
    subtypes = {}


    def __init__(self, type=None):
        if type != None:
            self.type = type
        else:
            self.type = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        subtype, = reader.peek('!H', 0)
        subclass = table_mod_prop.subtypes.get(subtype)
        if subclass:
            return subclass.unpack(reader)

        obj = table_mod_prop()
        obj.type = reader.read("!H")[0]
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.type != other.type: return False
        return True

    def pretty_print(self, q):
        q.text("table_mod_prop {")
        with q.group():
            with q.indent(2):
                q.breakable()
            q.breakable()
        q.text('}')


class eviction(table_mod_prop):
    type = 2

    def __init__(self, flags=None):
        if flags != None:
            self.flags = flags
        else:
            self.flags = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(struct.pack("!L", self.flags))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = eviction()
        _type = reader.read("!H")[0]
        assert(_type == 2)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.flags = reader.read("!L")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.flags != other.flags: return False
        return True

    def pretty_print(self, q):
        q.text("eviction {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("flags = ");
                value_name_map = {1: 'OFPTMPEF_OTHER', 2: 'OFPTMPEF_IMPORTANCE', 4: 'OFPTMPEF_LIFETIME'}
                q.text(util.pretty_flags(self.flags, value_name_map.values()))
            q.breakable()
        q.text('}')

table_mod_prop.subtypes[2] = eviction

class experimenter(table_mod_prop):
    subtypes = {}

    type = 65535

    def __init__(self, experimenter=None, exp_type=None):
        if experimenter != None:
            self.experimenter = experimenter
        else:
            self.experimenter = 0
        if exp_type != None:
            self.exp_type = exp_type
        else:
            self.exp_type = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(struct.pack("!L", self.experimenter))
        packed.append(struct.pack("!L", self.exp_type))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        subtype, = reader.peek('!L', 4)
        subclass = experimenter.subtypes.get(subtype)
        if subclass:
            return subclass.unpack(reader)

        obj = experimenter()
        _type = reader.read("!H")[0]
        assert(_type == 65535)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.experimenter = reader.read("!L")[0]
        obj.exp_type = reader.read("!L")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.experimenter != other.experimenter: return False
        if self.exp_type != other.exp_type: return False
        return True

    def pretty_print(self, q):
        q.text("experimenter {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("exp_type = ");
                q.text("%#x" % self.exp_type)
            q.breakable()
        q.text('}')

table_mod_prop.subtypes[65535] = experimenter

class vacancy(table_mod_prop):
    type = 3

    def __init__(self, vacancy_down=None, vacancy_up=None, vacancy=None):
        if vacancy_down != None:
            self.vacancy_down = vacancy_down
        else:
            self.vacancy_down = 0
        if vacancy_up != None:
            self.vacancy_up = vacancy_up
        else:
            self.vacancy_up = 0
        if vacancy != None:
            self.vacancy = vacancy
        else:
            self.vacancy = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(struct.pack("!B", self.vacancy_down))
        packed.append(struct.pack("!B", self.vacancy_up))
        packed.append(struct.pack("!B", self.vacancy))
        packed.append('\x00' * 1)
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = vacancy()
        _type = reader.read("!H")[0]
        assert(_type == 3)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.vacancy_down = reader.read("!B")[0]
        obj.vacancy_up = reader.read("!B")[0]
        obj.vacancy = reader.read("!B")[0]
        reader.skip(1)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.vacancy_down != other.vacancy_down: return False
        if self.vacancy_up != other.vacancy_up: return False
        if self.vacancy != other.vacancy: return False
        return True

    def pretty_print(self, q):
        q.text("vacancy {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("vacancy_down = ");
                q.text("%#x" % self.vacancy_down)
                q.text(","); q.breakable()
                q.text("vacancy_up = ");
                q.text("%#x" % self.vacancy_up)
                q.text(","); q.breakable()
                q.text("vacancy = ");
                q.text("%#x" % self.vacancy)
            q.breakable()
        q.text('}')

table_mod_prop.subtypes[3] = vacancy


